<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Mini - Standalone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
            --grinde: #8b5cf6;
            --buzan: #06b6d4;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.98);
            padding: 0.8rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--primary);
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .mode-toggle {
            display: flex;
            background: var(--light);
            padding: 4px;
            border-radius: 8px;
            gap: 4px;
        }

        .mode-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            background: transparent;
            transition: all 0.3s;
            font-size: 13px;
        }

        .mode-btn.active {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .mode-btn.grinde.active {
            color: var(--grinde);
        }

        .mode-btn.buzan.active {
            color: var(--buzan);
        }

        /* Language Switcher */
        .language-switcher {
            display: flex;
            background: var(--light);
            padding: 3px;
            border-radius: 8px;
            gap: 2px;
        }

        .lang-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            background: transparent;
            transition: all 0.3s;
            font-size: 12px;
        }

        .lang-btn.active {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Toolbar */
        .toolbar {
            background: white;
            padding: 0.8rem;
            display: flex;
            gap: 1rem;
            border-bottom: 1px solid var(--light);
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            padding: 6px 12px;
            border: 2px solid var(--light);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        /* Ensure SVG icons inside buttons follow the button color and animate when active */
        .btn svg {
            width: 16px;
            height: 16px;
            display: inline-block;
            vertical-align: middle;
            color: inherit; /* used by stroke="currentColor" */
            transition: color 0.15s ease, opacity 0.15s ease;
        }
        .btn svg path {
            stroke: currentColor;
            transition: stroke 0.15s ease, fill 0.15s ease;
        }

        .btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        /* Main Layout */
        .main-container {
            display: flex;
            height: calc(100vh - 120px);
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid var(--light);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
            margin-right: -280px;
        }

        .sidebar-tabs {
            display: flex;
            background: var(--light);
            border-bottom: 1px solid #e5e7eb;
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            transition: all 0.2s;
        }

        .sidebar-tab.active {
            background: white;
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .sidebar-section {
            margin-bottom: 1.5rem;
        }

        .sidebar-title {
            font-weight: 600;
            margin-bottom: 0.8rem;
            color: var(--dark);
            font-size: 0.9rem;
        }

        /* Canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            background: white;
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
            background-image: 
                radial-gradient(circle at 1px 1px, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        /* Properties Panel */
        .properties-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 280px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 1rem;
            display: none;
        }

        .properties-panel.active {
            display: block;
        }

        .property-group {
            margin-bottom: 1rem;
        }

        .property-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 4px;
        }

        .property-input {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--light);
            border-radius: 4px;
            font-size: 13px;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: var(--dark);
        }

        /* Stats Panel */
        .stats-panel {
            position: absolute;
            left: 20px;
            bottom: 20px;
            display: flex;
            gap: 1.2rem;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }

        .stat-label {
            font-size: 11px;
            color: var(--dark);
            opacity: 0.7;
            text-transform: uppercase;
        }

        /* Maps List */
        .map-item {
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .map-item:hover {
            background: var(--light);
            border-color: var(--primary);
        }

        .map-item.active {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
        }

        .map-item-title {
            font-weight: 500;
            font-size: 14px;
        }

        .map-item-meta {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 4px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 16px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--dark);
        }

        .close-btn {
            font-size: 1.5rem;
            cursor: pointer;
            background: none;
            border: none;
            color: var(--dark);
            opacity: 0.5;
        }

        .close-btn:hover {
            opacity: 1;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: var(--dark);
            color: white;
            border-radius: 8px;
            font-size: 14px;
            z-index: 2000;
            animation: slideUp 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .toast.success {
            background: var(--secondary);
        }

        .toast.error {
            background: var(--danger);
        }

        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        /* Template Grid */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .template-card {
            padding: 12px;
            border: 2px solid var(--light);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .template-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .template-icon {
            font-size: 1.8rem;
            margin-bottom: 4px;
        }

        .template-name {
            font-weight: 600;
            font-size: 12px;
        }

        /* Guides styling */
        .guide-card {
            border: 1px solid #e6e6e6;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            background: linear-gradient(180deg, #ffffff 0%, #fbfbfb 100%);
            box-shadow: 0 6px 18px rgba(0,0,0,0.04);
        }

        .guide-card-header {
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:8px;
        }

        .guide-card-title {
            display:flex;
            gap:8px;
            align-items:center;
            font-weight:700;
            color:var(--dark);
        }

        .guide-card-icon {
            width:36px;height:36px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;font-size:18px;background:#f3f4f6;color:var(--dark);
        }

        .guide-card-body { margin-top:8px; color:#374151; font-size:13px; line-height:1.45; }

        .guide-actions { margin-top:10px; display:flex; gap:8px; }

        .guide-collapse { cursor:pointer; color:var(--primary); font-weight:600; }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                z-index: 50;
                height: 100%;
            }
            
            .toolbar {
                flex-wrap: wrap;
            }
            
            .header-controls {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <span>üß†</span>
            <span data-i18n="app.title">Mind Map Mini</span>
        </div>
        
        <div class="header-controls">
                <div class="mode-toggle">
                <button class="mode-btn buzan active" onclick="setMode('buzan')">Buzan</button>
            </div>
            
            <div class="language-switcher">
                <button class="lang-btn fr active" onclick="setLanguage('fr')">üá´üá∑ FR</button>
                <button class="lang-btn en" onclick="setLanguage('en')">üá¨üáß EN</button>
            </div>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <!-- File group -->
        <div class="tool-group">
            <button class="btn" onclick="newMap()">üìÑ <span data-i18n="btn.new">Nouveau</span></button>
            <button class="btn" onclick="saveMap()">üíæ <span data-i18n="btn.save">Sauvegarder</span></button>
            <button class="btn" onclick="loadMapDialog()">üìÇ <span data-i18n="btn.open">Ouvrir</span></button>
            <button class="btn" onclick="exportMap('json')">üì§ <span data-i18n="btn.export">Export</span></button>
            <button class="btn" onclick="clearCanvas()">üóëÔ∏è <span data-i18n="btn.clear">Effacer</span></button>
        </div>

        <!-- Edit group -->
            <div class="tool-group">
            <button class="btn" onclick="setTool('select')">üëÜ <span data-i18n="tool.select">Select</span></button>
            <button class="btn" onclick="setTool('connect')" title="Connect" aria-label="Connect tool">
                <!-- small link icon SVG as logo -->
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                    <path d="M10.59 13.41a1 1 0 011.41 0l1.59 1.59a3 3 0 004.24 0 3 3 0 000-4.24l-2-2a3 3 0 00-4.24 0" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M13.41 10.59a1 1 0 00-1.41 0L10.41 12.59a3 3 0 01-4.24 0 3 3 0 010-4.24l2-2a3 3 0 014.24 0" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span style="margin-left:6px" data-i18n="tool.connect">Connecter</span>
            </button>
            <button class="btn" onclick="setTool('delete')">‚ùå <span data-i18n="tool.delete">Supprimer</span></button>
        </div>

        <!-- Draw group -->
        <div class="tool-group">
            <button class="btn" onclick="showQuickAddForType('central')">‚≠ê <span data-i18n="node.central">Central</span></button>
            <button class="btn" onclick="showQuickAddForType('group')">üì¶ <span data-i18n="node.group">Groupe</span></button>
            <button class="btn" onclick="showQuickAddForType('concept')">üí° <span data-i18n="node.concept">Concept</span></button>
            <button class="btn" onclick="showQuickAddForType('detail')">üìù <span data-i18n="node.detail">D√©tail</span></button>
        </div>

        <div class="tool-group" style="margin-left:auto;">
            <button class="btn" onclick="zoomIn()">üîç+</button>
            <button class="btn" onclick="zoomOut()">üîç-</button>
            <button class="btn" onclick="resetView()">üîÑ</button>
            <button class="btn" onclick="toggleSidebar()">üìä</button>
            <label style="display:flex; align-items:center; gap:6px; margin-left:8px;">
                <input type="checkbox" id="autosaveToggle" onchange="toggleAutosave(this.checked)" checked>
                <span style="font-size:12px;" data-i18n="toolbar.autosave">AutoSave</span>
            </label>
        </div>
    </div>

    <!-- left toolbox removed -->

    <!-- Quick-add floating form -->
    <div id="quickAdd" style="position:fixed; left:50%; top:120px; transform:translateX(-50%); z-index:900; display:none;">
        <div style="background:white; padding:10px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.1); display:flex; gap:8px; align-items:center;">
            <input id="quickAddText" placeholder="Node text" style="padding:6px; border:1px solid var(--light); border-radius:6px; min-width:220px;" />
            <button class="btn btn-primary" onclick="addNodeFromQuickAdd()" id="quickAddOk">Add</button>
            <button class="btn" onclick="hideQuickAdd()" id="quickAddCancel">Cancel</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" onclick="showSidebarTab('maps')">
                    <span data-i18n="sidebar.maps">Mes Cartes</span>
                </button>
                <button class="sidebar-tab" onclick="showSidebarTab('templates')">
                    <span data-i18n="sidebar.templates">Mod√®les</span>
                </button>
                <button class="sidebar-tab" onclick="showSidebarTab('help')">
                    <span data-i18n="sidebar.help">Aide</span>
                </button>
                <button class="sidebar-tab" onclick="showSidebarTab('guides')">
                    <span data-i18n="sidebar.guides">Guides</span>
                </button>
            </div>
            
            <div class="sidebar-content">
                <!-- Maps Tab -->
                <div id="maps-tab" class="sidebar-pane">
                    <div class="sidebar-section">
                        <div class="sidebar-title" data-i18n="sidebar.recent">Cartes R√©centes</div>
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                <input type="checkbox" id="selectAllMaps" onchange="toggleSelectAll(this.checked)">
                                <label for="selectAllMaps"><span data-i18n="maps.select_all">Tout s√©lectionner</span></label>
                                <button id="deleteSelectedBtn" class="btn" style="margin-left:auto; padding:4px 8px;" onclick="deleteSelectedSavedMaps()" data-i18n="maps.delete_selected">Supprimer s√©lection</button>
                            </div>
                            <div id="mapsList"></div>
                    </div>
                </div>
                
                <!-- Templates Tab -->
                <div id="templates-tab" class="sidebar-pane" style="display: none;">
                    <div class="sidebar-section">
                        <div class="sidebar-title" data-i18n="sidebar.templates">Mod√®les</div>
                        <div class="template-grid">
                            <div class="template-card" onclick="loadTemplate('business-plan')">
                                <div class="template-icon">üìä</div>
                                <div class="template-name" data-i18n="template.business">Business Plan</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('study-notes')">
                                <div class="template-icon">üìö</div>
                                <div class="template-name" data-i18n="template.study">Notes</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('project')">
                                <div class="template-icon">üíº</div>
                                <div class="template-name" data-i18n="template.project">Projet</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('brainstorm')">
                                <div class="template-icon">üß†</div>
                                <div class="template-name" data-i18n="template.brainstorm">Brainstorm</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Help Tab -->
                <div id="help-tab" class="sidebar-pane" style="display: none;">
                    <div class="sidebar-section">
                        <div class="sidebar-title" data-i18n="help.title">Aide Rapide</div>
                        <div id="jobAid" style="font-size: 13px; line-height: 1.6;">
                            <!-- Job aid content populated by setLanguage() -->
                        </div>
                        <div style="margin-top:12px;">
                            <div class="sidebar-title">Quick Tips</div>
                            <ul style="font-size:13px; margin-left:16px;">
                                <li>Use the select tool to move nodes. Drag to reposition.</li>
                                <li>Use the connect tool to draw links between nodes.</li>
                                <li>Rectangle nodes remain horizontally aligned while resizing; use the Rotation slider to rotate.</li>
                                <li>Autosave can be toggled in the toolbar.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Guides Tab -->
                <div id="guides-tab" class="sidebar-pane" style="display: none;">
                    <div class="sidebar-section">
                        <div class="sidebar-title" data-i18n="guides.title">Guides et M√©thodes</div>

                        <div class="guide-card" id="guide-buzan">
                            <div class="guide-card-header">
                                <div class="guide-card-title"><div class="guide-card-icon">üß†</div><div><div data-i18n="guides.buzan.title">M√©thode BUZAN</div><div style="font-size:12px; color:#6b7280;">Apprenez la pens√©e visuelle</div></div></div>
                                <div class="guide-collapse" onclick="toggleGuide('buzan')">Voir</div>
                            </div>
                            <div class="guide-card-body" id="guide-buzan-body" style="display:none;">
                                <p data-i18n="guides.buzan.p1">La m√©thode Buzan met l'accent sur les associations visuelles, les couleurs, et la hi√©rarchie. Utilisez des branches color√©es et des images pour stimuler la m√©moire.</p>
                                <p data-i18n="guides.buzan.p2">Conseils rapides : commencez par un sujet central, d√©veloppez des branches principales, utilisez des mots-cl√©s courts et des ic√¥nes.</p>
                                <div class="guide-actions"><button class="btn" onclick="openGuide()">Lire le guide complet</button></div>
                            </div>
                        </div>

                        <div class="guide-card" id="guide-business">
                            <div class="guide-card-header">
                                <div class="guide-card-title"><div class="guide-card-icon">üìà</div><div><div data-i18n="guides.business.title">Business Analysis</div><div style="font-size:12px; color:#6b7280;">Cartographier processus & risques</div></div></div>
                                <div class="guide-collapse" onclick="toggleGuide('business')">Voir</div>
                            </div>
                            <div class="guide-card-body" id="guide-business-body" style="display:none;">
                                <p data-i18n="guides.business.p1">Utilisez le mind mapping pour cartographier les parties prenantes, les processus cl√©s, les risques et les opportunit√©s. Structurez par th√®mes (Ex: Finance, Produit, Clients).</p>
                                <p data-i18n="guides.business.p2">M√©thode : identifiez l'objectif, capturez les hypoth√®ses, mappez les d√©pendances, priorisez les actions.</p>
                                <div class="guide-actions"><button class="btn" onclick="loadTemplate('business-plan')">Charger le template Business</button></div>
                            </div>
                        </div>

                        <div class="guide-card" id="guide-study">
                            <div class="guide-card-header">
                                <div class="guide-card-title"><div class="guide-card-icon">üìö</div><div><div data-i18n="guides.study.title">Study Template & Build Your Own</div><div style="font-size:12px; color:#6b7280;">√âtudier ou construire</div></div></div>
                                <div class="guide-collapse" onclick="toggleGuide('study')">Voir</div>
                            </div>
                            <div class="guide-card-body" id="guide-study-body" style="display:none;">
                                <p data-i18n="guides.study.p1">Choix rapide : chargez le mod√®le 'Study Notes' pour une structure d'√©tude pr√™te √† l'emploi, ou cr√©ez votre propre carte vide.</p>
                                <p data-i18n="guides.study.p2">Astuce : ajoutez une racine, puis des enfants, utilisez des couleurs pour les th√®mes, et ajoutez des √©tiquettes aux connexions pour clarifier les relations.</p>
                                <div class="guide-actions">
                                    <button class="btn" onclick="loadTemplate('study-notes')">Charger Study Notes</button>
                                    <button class="btn" onclick="newMap(); closeProperties();">Cr√©er une carte vide</button>
                                </div>
                            </div>
                        </div>

                        <div class="guide-card">
                            <div class="guide-card-header">
                                <div class="guide-card-title"><div class="guide-card-icon">‚ö°</div><div><div data-i18n="guides.quicktips">Quick Tips</div></div></div>
                                <div></div>
                            </div>
                            <div class="guide-card-body">
                                <ul style="margin-left:16px;">
                                    <li data-i18n="guides.tip.1">Utilisez des couleurs coh√©rentes par th√®me.</li>
                                    <li data-i18n="guides.tip.2">Gardez des mots-cl√©s courts pour une lecture rapide.</li>
                                    <li data-i18n="guides.tip.3">Annoter les connexions pour expliquer le type de relation.</li>
                                </ul>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            
            <!-- Properties Panel -->
            <div class="properties-panel" id="propertiesPanel">
                    <div class="property-group">
                        <div class="property-label" data-i18n="property.text">Texte</div>
                        <input type="text" class="property-input" id="nodeText" onchange="updateNodeProperty('text')">
                    </div>

                    <div class="property-group">
                        <div class="property-label">Text Size</div>
                        <input type="number" class="property-input" id="nodeTextSize" min="8" max="72" onchange="updateNodeProperty('textSize')">
                    </div>

                    <div class="property-group">
                        <div class="property-label" data-i18n="property.size">Taille</div>
                        <input type="range" class="property-input" id="nodeSize" min="10" max="80" onchange="updateNodeProperty('size')">
                    </div>

                    <div class="property-group">
                        <div class="property-label">Text Color</div>
                        <input type="color" class="property-input" id="nodeTextColor" onchange="updateNodeProperty('textColor')">
                    </div>

                    <div class="property-group">
                        <div class="property-label" data-i18n="property.color">Couleur</div>
                        <input type="color" class="property-input" id="nodeColor" onchange="updateNodeProperty('color')">
                    </div>

                    <div class="property-group">
                        <div class="property-label">Shape</div>
                        <select id="nodeShape" class="property-input" onchange="updateNodeProperty('shape')">
                            <option value="rounded">Rounded</option>
                            <option value="rect">Rectangle</option>
                            <option value="circle">Circle</option>
                        </select>
                    </div>

                    <div class="property-group">
                        <div class="property-label" data-i18n="prop.corner_radius">Rayon coins (arrondi)</div>
                        <input type="range" class="property-input" id="nodeCornerRadius" min="0" max="40" onchange="updateNodeProperty('cornerRadius')">
                    </div>

                    <div class="property-group">
                        <div class="property-label">Rotation (¬∞)</div>
                        <input type="range" class="property-input" id="nodeRotation" min="0" max="360" onchange="updateNodeProperty('rotation')">
                    </div>

                    <div class="property-group">
                        <div class="property-label">Preview</div>
                        <canvas id="propPreview" width="240" height="80" style="border:1px solid #eee; border-radius:6px;"></canvas>
                    </div>

                    <div style="display:flex; gap:8px; margin-top:8px;">
                        <button id="propSaveBtn" class="btn btn-primary" style="flex:1" onclick="saveProperties()">Save</button>
                        <button id="propCancelBtn" class="btn" style="flex:1" onclick="cancelProperties()">Cancel</button>
                    </div>
            </div>
            
            <!-- Arrow Properties Panel -->
            <div class="properties-panel" id="arrowPropertiesPanel" style="right:320px;">
                <div class="property-group">
                    <div class="property-label">Arrow ID</div>
                    <input type="text" class="property-input" id="arrowId" readonly>
                </div>
                <div class="property-group">
                    <div class="property-label">Label</div>
                    <input type="text" class="property-input" id="arrowText">
                </div>
                <div style="display:flex; gap:8px; margin-top:8px;">
                    <button class="btn btn-primary" style="flex:1" onclick="saveArrowProperties()">Save</button>
                    <button class="btn" style="flex:1" onclick="cancelArrowProperties()">Cancel</button>
                </div>
            </div>
            
            <!-- Stats Panel -->
            <div class="stats-panel">
                <div class="stat">
                    <div class="stat-value" id="nodeCount">0</div>
                    <div class="stat-label" data-i18n="stat.nodes">N≈ìuds</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="connectionCount">0</div>
                    <div class="stat-label" data-i18n="stat.links">Liens</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="currentMode">GRINDE</div>
                    <div class="stat-label" data-i18n="stat.mode">Mode</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Map Modal -->
    <div class="modal" id="loadModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" data-i18n="modal.load">Charger une carte</h2>
                <button class="close-btn" onclick="closeModal('loadModal')">&times;</button>
            </div>
            <div id="loadMapsList"></div>
        </div>
    </div>

    <!-- Guide Modal -->
    <div class="modal" id="guideModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Guide</h2>
                <button class="close-btn" onclick="closeModal('guideModal')">&times;</button>
            </div>
            <div style="font-size:13px; line-height:1.6;">
                <h3>Quick Start</h3>
                <ol>
                    <li>Create nodes with the toolbar or double-click.</li>
                    <li>Select a node to edit its properties (size, color, rotation).</li>
                    <li>Use Connect to create links; Delete tool removes nodes.</li>
                </ol>
                <h3>Tips</h3>
                <ul>
                    <li>Rectangles stay horizontal when resized. Use rotation to tilt them.</li>
                    <li>Autosave is enabled by default; disable if you prefer manual saves.</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ===============================
        // Internationalization (i18n)
        // ===============================
        const i18n = {
            fr: {
                'app.title': 'Mind Map Mini',
                'btn.new': 'Nouveau',
                'btn.save': 'Sauvegarder',
                'btn.open': 'Ouvrir',
                'btn.export': 'Export',
                'btn.clear': 'Effacer',
                'btn.close': 'Fermer',
                'node.central': 'Central',
                'node.group': 'Groupe',
                'node.concept': 'Concept',
                'node.detail': 'D√©tail',
                'tool.select': 'Select',
                'tool.connect': 'Connecter',
                'tool.delete': 'Supprimer',
                'sidebar.maps': 'Mes Cartes',
                'sidebar.templates': 'Mod√®les',
                'sidebar.help': 'Aide',
                'sidebar.recent': 'Cartes R√©centes',
                'template.business': 'Business Plan',
                'template.study': 'Notes',
                'template.project': 'Projet',
                'template.brainstorm': 'Brainstorm',
                'property.text': 'Texte',
                'property.size': 'Taille',
                'property.color': 'Couleur',
                'stat.nodes': 'N≈ìuds',
                'stat.links': 'Liens',
                'stat.mode': 'Mode',
                'help.title': 'Aide Rapide',
                'modal.load': 'Charger une carte',
                'prompt.node.text': 'Entrez le texte du n≈ìud :',
                'prompt.map.title': 'Titre de la carte :',
                'toast.saved': 'Carte sauvegard√©e !',
                'toast.loaded': 'Carte charg√©e !',
                'toast.exported': 'Carte export√©e !',
                'toast.deleted': 'Supprim√© !',
                'confirm.new': 'Cr√©er une nouvelle carte ? Les modifications non sauvegard√©es seront perdues.',
                'confirm.delete': 'Supprimer ce n≈ìud ?'
                ,
                'jobaid.title': 'Guide d\'utilisation',
                'jobaid.lines': [
                    'Changer la Langue',
                    'Cliquez sur üá´üá∑ FR ou üá¨üáß EN dans l\'en-t√™te',
                    'L\'interface se met √† jour instantan√©ment',
                    'La pr√©f√©rence est sauvegard√©e',
                    '',
                    'Cr√©er une Carte avec Template',
                    'Cliquez sur l\'onglet Mod√®les dans la sidebar',
                    'Choisissez un template (ex: Plan d\'Affaires)',
                    'Le template se charge avec la structure pr√©d√©finie',
                    'Modifiez selon vos besoins',
                    '',
                    'Voir le Score GRINDE',
                    'Cr√©ez votre carte en mode GRINDE',
                    'Le score s\'affiche automatiquement dans les exports',
                    'Visez 80+ pour une carte optimale !'
                ]
                ,
                'maps.select_all': 'Tout s√©lectionner',
                'maps.delete_selected': 'Supprimer s√©lection',
                'confirm.delete_selected': 'Supprimer les cartes s√©lectionn√©es ?'
                ,
                'prop.text': 'Texte',
                'prop.text_size': 'Taille du texte',
                'prop.node_size': 'Taille du n≈ìud',
                'prop.text_color': 'Couleur du texte',
                'prop.fill_color': 'Couleur',
                'prop.shape': 'Forme',
                'prop.save': 'Enregistrer',
                'prop.cancel': 'Annuler',
                'prop.corner_radius': 'Rayon coins (arrondi)'
            },
            en: {
                'app.title': 'Mind Map Mini',
                'btn.new': 'New',
                'btn.save': 'Save',
                'btn.open': 'Open',
                'btn.export': 'Export',
                'btn.clear': 'Clear',
                'btn.close': 'Close',
                'node.central': 'Central',
                'node.group': 'Group',
                'node.concept': 'Concept',
                'node.detail': 'Detail',
                'tool.select': 'Select',
                'tool.connect': 'Connect',
                'tool.delete': 'Delete',
                'sidebar.maps': 'My Maps',
                'sidebar.templates': 'Templates',
                'sidebar.help': 'Help',
                'sidebar.recent': 'Recent Maps',
                'template.business': 'Business Plan',
                'template.study': 'Notes',
                'template.project': 'Project',
                'template.brainstorm': 'Brainstorm',
                'property.text': 'Text',
                'property.size': 'Size',
                'property.color': 'Color',
                'stat.nodes': 'Nodes',
                'stat.links': 'Links',
                'stat.mode': 'Mode',
                'help.title': 'Quick Help',
                'modal.load': 'Load a map',
                'prompt.node.text': 'Enter node text:',
                'prompt.map.title': 'Map title:',
                'toast.saved': 'Map saved!',
                'toast.loaded': 'Map loaded!',
                'toast.exported': 'Map exported!',
                'toast.deleted': 'Deleted!',
                'confirm.new': 'Create new map? Unsaved changes will be lost.',
                'confirm.delete': 'Delete this node?'
                ,
                'jobaid.title': 'User Guide',
                'jobaid.lines': [
                    'Change Language',
                    'Click üá´üá∑ FR or üá¨üáß EN in the header',
                    'The interface updates instantly',
                    'Preference is saved',
                    '',
                    'Create a Map from a Template',
                    'Click the Templates tab in the sidebar',
                    'Choose a template (e.g. Business Plan)',
                    'The template loads with a predefined structure',
                    'Edit it to fit your needs',
                    '',
                    'See the GRINDE Score',
                    'Create your map in GRINDE mode',
                    'The score is automatically included in exports',
                    'Aim for 80+ for an optimal map!'
                ]
                ,
                'maps.select_all': 'Select all',
                'maps.delete_selected': 'Delete selected',
                'confirm.delete_selected': 'Delete selected maps?'
                ,
                'prop.text': 'Text',
                'prop.text_size': 'Text size',
                'prop.node_size': 'Node size',
                'prop.text_color': 'Text color',
                'prop.fill_color': 'Fill color',
                'prop.shape': 'Shape',
                'prop.save': 'Save',
                'prop.cancel': 'Cancel',
                'prop.corner_radius': 'Corner radius (rounded)'
            }
        };

    // toolbox removed

        // Add Guides strings for both languages
        i18n.fr['sidebar.guides'] = 'Guides';
        i18n.fr['guides.title'] = 'Guides et M√©thodes';
        i18n.fr['guides.buzan.title'] = 'M√©thode BUZAN';
        i18n.fr['guides.buzan.p1'] = "La m√©thode Buzan met l'accent sur les associations visuelles, les couleurs, et la hi√©rarchie. Utilisez des branches color√©es et des images pour stimuler la m√©moire.";
        i18n.fr['guides.buzan.p2'] = "Conseils rapides : commencez par un sujet central, d√©veloppez des branches principales, utilisez des mots-cl√©s courts et des ic√¥nes.";
        i18n.fr['guides.business.title'] = 'Business Analysis';
        i18n.fr['guides.business.p1'] = "Utilisez le mind mapping pour cartographier les parties prenantes, les processus cl√©s, les risques et les opportunit√©s.";
        i18n.fr['guides.business.p2'] = "M√©thode : identifiez l'objectif, capturez les hypoth√®ses, mappez les d√©pendances, priorisez les actions.";
        i18n.fr['guides.study.title'] = 'Study & Build';
        i18n.fr['guides.study.p1'] = 'Choix rapide : chargez le mod√®le Study Notes ou cr√©ez votre propre carte vide.';
        i18n.fr['guides.study.p2'] = 'Astuce : ajoutez racine ‚Üí enfants ‚Üí th√®mes, utilisez des couleurs.';
        i18n.fr['guides.quicktips'] = 'Conseils rapides';
        i18n.fr['guides.tip.1'] = 'Utilisez des couleurs coh√©rentes par th√®me.';
        i18n.fr['guides.tip.2'] = 'Gardez des mots-cl√©s courts pour une lecture rapide.';
        i18n.fr['guides.tip.3'] = 'Annoter les connexions pour expliquer le type de relation.';

        i18n.en['sidebar.guides'] = 'Guides';
        i18n.en['guides.title'] = 'Guides & Methods';
        i18n.en['guides.buzan.title'] = 'BUZAN Method';
        i18n.en['guides.buzan.p1'] = 'The Buzan method focuses on visual associations, colors, and hierarchy. Use colored branches and images to boost memory.';
        i18n.en['guides.buzan.p2'] = 'Quick tips: start with a central topic, develop main branches, use short keywords and icons.';
        i18n.en['guides.business.title'] = 'Business Analysis';
        i18n.en['guides.business.p1'] = 'Use mind mapping to map stakeholders, key processes, risks and opportunities.';
        i18n.en['guides.business.p2'] = 'Method: identify objective, capture assumptions, map dependencies, prioritize actions.';
        i18n.en['guides.study.title'] = 'Study & Build';
        i18n.en['guides.study.p1'] = "Quick choice: load the 'Study Notes' template or create your own blank map.";
        i18n.en['guides.study.p2'] = 'Tip: add root ‚Üí children ‚Üí themes, use colors.';
        i18n.en['guides.quicktips'] = 'Quick Tips';
        i18n.en['guides.tip.1'] = 'Use consistent colors per theme.';
        i18n.en['guides.tip.2'] = 'Keep keywords short for quick scanning.';
        i18n.en['guides.tip.3'] = 'Label connections to clarify relationship types.';

        // ===============================
        // Global State
        // ===============================
        let currentLanguage = localStorage.getItem('language') || 'fr';
        let currentMap = {
            id: null,
            title: 'Mind Map',
            mode: 'buzan',
            nodes: [],
            connections: [],
            created: new Date().toISOString(),
            modified: new Date().toISOString()
        };
        
        let selectedNode = null;
    let editingNode = null; // temporary buffer for properties panel
        let selectedConnection = null;
        let currentTool = 'select';
        let isDragging = false;
        let isConnecting = false;
        let connectStart = null;
        let dragOffset = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };
        let zoom = 1;
        let canvas, ctx;
    // Undo/redo history (stores serialized map states)
    let history = [];
    let historyIndex = -1;
    let autosaveEnabled = true;

        // ===============================
        // Node Class
        // ===============================
        class Node {
            constructor(x, y, text, type = 'concept') {
                this.id = 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.text = text;
                this.type = type;
                this.size = this.getDefaultSize();
                this.color = this.getDefaultColor();
                // new properties
                this.textSize = Math.round(this.size * 0.7);
                this.textColor = this.type === 'detail' ? '#1f2937' : '#ffffff';
                this.shape = 'rounded'; // 'rounded' | 'rect' | 'circle'
                this.cornerRadius = 8;
                this.rotation = 0; // degrees
            }
            
            getDefaultSize() {
                const sizes = {
                    'central': 30,
                    'group': 25,
                    'concept': 20,
                    'detail': 15
                };
                return sizes[this.type] || 20;
            }
            
            getDefaultColor() {
                const colors = {
                    'central': '#6366f1',
                    'group': '#f59e0b',
                    'concept': '#10b981',
                    'detail': '#9ca3af'
                };
                return colors[this.type] || '#6366f1';
            }
            
            draw(ctx) {
                ctx.save();
                
                // Shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw node shape
                ctx.fillStyle = this.color;
                ctx.strokeStyle = selectedNode === this ? '#1f2937' : '#ffffff';
                ctx.lineWidth = selectedNode === this ? 3 : 2;

                const width = Math.max(this.text.length * 7 + 20, 80);
                const height = this.size * 2;

                if (this.shape === 'circle') {
                    ctx.beginPath();
                    const radius = Math.max(this.size, width/2);
                    ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.shape === 'rect' || this.shape === 'rounded') {
                    // Keep rectangle oriented horizontally: apply rotation only for circle/rounded? user requested keep horizontal when sizing and allow rotation ‚Äî we'll apply rotation only for circle/rounded by default, but allow manual rotation for rect via property
                    ctx.save();
                    // translate to center and rotate around center
                    ctx.translate(this.x, this.y);
                    ctx.rotate((this.rotation || 0) * Math.PI / 180);
                    if (this.shape === 'rect') {
                        ctx.fillRect(-width/2, -height/2, width, height);
                        ctx.strokeRect(-width/2, -height/2, width, height);
                    } else {
                        const radius = this.cornerRadius || 8;
                        ctx.beginPath();
                        ctx.moveTo(-width/2 + radius, -height/2);
                        ctx.lineTo(width/2 - radius, -height/2);
                        ctx.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
                        ctx.lineTo(width/2, height/2 - radius);
                        ctx.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
                        ctx.lineTo(-width/2 + radius, height/2);
                        ctx.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
                        ctx.lineTo(-width/2, -height/2 + radius);
                        ctx.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                    ctx.restore();
                } else {
                    // circle
                    ctx.beginPath();
                    const radius = Math.max(this.size, width/2);
                    ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                // Text
                ctx.fillStyle = this.textColor || (this.type === 'detail' ? '#1f2937' : '#ffffff');
                const fontSize = this.textSize || Math.round(this.size * 0.7);
                ctx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
                
                ctx.restore();
            }
            
            isPointInside(x, y) {
                const width = Math.max(this.text.length * 7 + 20, 80);
                const height = this.size * 2;
                return x >= this.x - width/2 && x <= this.x + width/2 &&
                       y >= this.y - height/2 && y <= this.y + height/2;
            }
        }

        // ===============================
        // Connection Class
        // ===============================
        class Connection {
            constructor(source, target, type = 'simple') {
                this.id = 'conn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.source = source;
                this.target = target;
                this.type = type;
                this.color = '#6366f1';
                this.text = '';
            }
            
            draw(ctx) {
                ctx.save();

                // Highlight when selected
                ctx.strokeStyle = (typeof selectedConnection !== 'undefined' && selectedConnection === this) ? '#ef4444' : this.color;
                ctx.lineWidth = (typeof selectedConnection !== 'undefined' && selectedConnection === this) ? 4 : 2;
                
                let drewCurve = false;
                if (currentMap.mode === 'grinde' || this.type === 'curved') {
                    // Curved connection (GRINDE default or explicit curved type)
                    ctx.beginPath();
                    ctx.moveTo(this.source.x, this.source.y);
                    const cp1x = (this.source.x + this.target.x) / 2;
                    const cp1y = this.source.y;
                    const cp2x = (this.source.x + this.target.x) / 2;
                    const cp2y = this.target.y;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, this.target.x, this.target.y);
                    ctx.stroke();
                    drewCurve = true;
                }

                if (!drewCurve) {
                    // Straight connection for Buzan / default
                    ctx.beginPath();
                    ctx.moveTo(this.source.x, this.source.y);
                    ctx.lineTo(this.target.x, this.target.y);
                    ctx.stroke();
                }
                
                // Arrow if needed
                if (this.type === 'arrow') {
                    let angle;
                    if (drewCurve) {
                        // approximate tangent at end of bezier using last control point
                        const cp2x = (this.source.x + this.target.x) / 2;
                        const cp2y = this.target.y;
                        const dx = this.target.x - cp2x;
                        const dy = this.target.y - cp2y;
                        angle = Math.atan2(dy, dx);
                    } else {
                        angle = Math.atan2(this.target.y - this.source.y, this.target.x - this.source.x);
                    }
                    const arrowLength = 12;
                    const arrowAngle = Math.PI / 6;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.target.x, this.target.y);
                    ctx.lineTo(
                        this.target.x - arrowLength * Math.cos(angle - arrowAngle),
                        this.target.y - arrowLength * Math.sin(angle - arrowAngle)
                    );
                    ctx.moveTo(this.target.x, this.target.y);
                    ctx.lineTo(
                        this.target.x - arrowLength * Math.cos(angle + arrowAngle),
                        this.target.y - arrowLength * Math.sin(angle + arrowAngle)
                    );
                    ctx.stroke();
                }
                // Draw connection text/label if present
                if (this.text) {
                    ctx.save();
                    ctx.fillStyle = '#111';
                    ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    let tx = (this.source.x + this.target.x) / 2;
                    let ty = (this.source.y + this.target.y) / 2;
                    if (currentMap.mode === 'grinde') {
                        // compute point on bezier at t=0.5 using same control points
                        const x1 = this.source.x, y1 = this.source.y;
                        const x4 = this.target.x, y4 = this.target.y;
                        const x2 = (x1 + x4) / 2, y2 = y1;
                        const x3 = (x1 + x4) / 2, y3 = y4;
                        const t = 0.5;
                        const cx = Math.pow(1 - t, 3) * x1 + 3 * Math.pow(1 - t, 2) * t * x2 + 3 * (1 - t) * Math.pow(t, 2) * x3 + Math.pow(t, 3) * x4;
                        const cy = Math.pow(1 - t, 3) * y1 + 3 * Math.pow(1 - t, 2) * t * y2 + 3 * (1 - t) * Math.pow(t, 2) * y3 + Math.pow(t, 3) * y4;
                        tx = cx; ty = cy;
                    }

                    // background box for readability
                    const padding = 6;
                    const textWidth = ctx.measureText(this.text).width;
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    ctx.fillRect(tx - textWidth/2 - padding, ty - 12, textWidth + padding*2, 24);
                    ctx.fillStyle = '#111';
                    ctx.fillText(this.text, tx, ty);
                    ctx.restore();
                }
                
                ctx.restore();
            }
        }

        // ===============================
        // Connection hit-testing helpers
        // ===============================
        function distancePointToSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            if (len_sq !== 0) param = dot / len_sq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function isPointNearConnection(conn, px, py, threshold = 8) {
            if (!conn || !conn.source || !conn.target) return false;
            if (currentMap.mode === 'grinde') {
                // cubic bezier using same control points as draw
                const x1 = conn.source.x, y1 = conn.source.y;
                const x4 = conn.target.x, y4 = conn.target.y;
                const x2 = (x1 + x4) / 2, y2 = y1;
                const x3 = (x1 + x4) / 2, y3 = y4;

                // sample points along bezier and check distance to segments
                const samples = 20;
                let prevX = x1, prevY = y1;
                for (let i = 1; i <= samples; i++) {
                    const t = i / samples;
                    // cubic bezier formula
                    const cx = Math.pow(1 - t, 3) * x1 + 3 * Math.pow(1 - t, 2) * t * x2 + 3 * (1 - t) * Math.pow(t, 2) * x3 + Math.pow(t, 3) * x4;
                    const cy = Math.pow(1 - t, 3) * y1 + 3 * Math.pow(1 - t, 2) * t * y2 + 3 * (1 - t) * Math.pow(t, 2) * y3 + Math.pow(t, 3) * y4;
                    const dist = distancePointToSegment(px, py, prevX, prevY, cx, cy);
                    if (dist <= threshold) return true;
                    prevX = cx; prevY = cy;
                }
                return false;
            } else {
                // straight line
                return distancePointToSegment(px, py, conn.source.x, conn.source.y, conn.target.x, conn.target.y) <= threshold;
            }
        }

        // ===============================
        // Templates
        // ===============================
        const templates = {
            'business-plan': {
                title: 'Business Plan',
                mode: 'buzan',
                nodes: [
                    {text: 'üìä Business Plan', type: 'central', x: 400, y: 300},
                    {text: 'üíº Vision', type: 'group', x: 200, y: 150},
                    {text: 'üéØ Market', type: 'group', x: 600, y: 150},
                    {text: 'üì¶ Product', type: 'group', x: 200, y: 450},
                    {text: 'üí∞ Finance', type: 'group', x: 600, y: 450}
                ]
            },
            'study-notes': {
                title: 'Study Notes',
                mode: 'buzan',
                nodes: [
                    {text: 'üìö Course', type: 'central', x: 400, y: 300},
                    {text: 'üîë Key Concepts', type: 'group', x: 250, y: 200},
                    {text: 'üí° Examples', type: 'group', x: 550, y: 200},
                    {text: '‚ùì Questions', type: 'group', x: 250, y: 400},
                    {text: '‚ö° Remember', type: 'group', x: 550, y: 400}
                ]
            },
            'project': {
                title: 'Project',
                mode: 'buzan',
                nodes: [
                    {text: 'üíº Project', type: 'central', x: 400, y: 300},
                    {text: 'üéØ Goals', type: 'group', x: 200, y: 200},
                    {text: 'üë• Team', type: 'group', x: 600, y: 200},
                    {text: 'üìã Tasks', type: 'group', x: 200, y: 400},
                    {text: 'üìÖ Timeline', type: 'group', x: 600, y: 400}
                ]
            },
            'brainstorm': {
                title: 'Brainstorm',
                mode: 'buzan',
                nodes: [
                    {text: 'üí° Main Idea', type: 'central', x: 400, y: 300}
                ]
            }
        };

        // ===============================
        // Initialize
        // ===============================
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            setLanguage(currentLanguage);
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Event listeners
            canvas.addEventListener('dblclick', handleDoubleClick);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            document.addEventListener('keydown', handleKeyDown);

            // keyboard undo/redo
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { e.preventDefault(); redo(); }
            });
            
            // Load saved maps
            loadMapsList();
            
            // Start with new map
            newMap();

            // wire quick add Enter key
            const qa = document.getElementById('quickAddText');
            if (qa) {
                qa.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter') addNodeFromQuickAdd();
                    if (ev.key === 'Escape') hideQuickAdd();
                });
            }

            // Save initial state to history
            saveHistory();
            
            // Auto-save every 30 seconds
            setInterval(autoSave, 30000);
            
            // Start render loop
            render();
        }

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }

        // ===============================
        // Rendering
        // ===============================
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(zoom, zoom);
            
            // Draw connections
            currentMap.connections.forEach(conn => conn.draw(ctx));
            
            // Draw nodes
            currentMap.nodes.forEach(node => node.draw(ctx));
            
            // Draw connecting line if in connect mode
            if (isConnecting && connectStart) {
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(connectStart.x, connectStart.y);
                const rect = canvas.getBoundingClientRect();
                const mouseX = (lastMouseX - rect.left - panOffset.x) / zoom;
                const mouseY = (lastMouseY - rect.top - panOffset.y) / zoom;
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.restore();
            
            updateStats();
            requestAnimationFrame(render);
        }

        // ===============================
        // Event Handlers
        // ===============================
        let lastMouseX = 0, lastMouseY = 0;

        function handleDoubleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoom;
            const y = (e.clientY - rect.top - panOffset.y) / zoom;
            
            const text = prompt(t('prompt.node.text'));
            if (text) {
                const node = new Node(x, y, text, 'concept');
                currentMap.nodes.push(node);
                saveHistory();
                saveHistory();
                autoSave();
            }
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoom;
            const y = (e.clientY - rect.top - panOffset.y) / zoom;
            
            if (currentTool === 'delete') {
                // Delete mode
                for (let i = currentMap.nodes.length - 1; i >= 0; i--) {
                    if (currentMap.nodes[i].isPointInside(x, y)) {
                        const nodeToDelete = currentMap.nodes[i];
                        currentMap.nodes.splice(i, 1);
                        // Remove connections
                        currentMap.connections = currentMap.connections.filter(
                            c => c.source !== nodeToDelete && c.target !== nodeToDelete
                        );
                        saveHistory();
                        autoSave();
                        return;
                    }
                }
            } else if (currentTool === 'connect') {
                // Connect mode
                for (let node of currentMap.nodes) {
                    if (node.isPointInside(x, y)) {
                        if (!isConnecting) {
                            isConnecting = true;
                            connectStart = node;
                        } else {
                            if (connectStart !== node) {
                                const conn = new Connection(connectStart, node);
                                currentMap.connections.push(conn);
                                saveHistory();
                                autoSave();
                            }
                            isConnecting = false;
                            connectStart = null;
                        }
                        return;
                    }
                }
            } else {
                // Select mode
                selectedNode = null;
                for (let node of currentMap.nodes) {
                    if (node.isPointInside(x, y)) {
                        selectedNode = node;
                        isDragging = true;
                        dragOffset.x = x - node.x;
                        dragOffset.y = y - node.y;
                        showProperties(node);
                        return;
                    }
                }

                // Check if clicking on a connection
                selectedConnection = null;
                for (let connection of currentMap.connections) {
                    if (isPointNearConnection(connection, x, y)) {
                        selectedConnection = connection;
                        showArrowPropertiesPanel(connection);
                        return;
                    }
                }

                // Pan with shift
                if (e.shiftKey) {
                    canvas.style.cursor = 'grabbing';
                }
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoom;
            const y = (e.clientY - rect.top - panOffset.y) / zoom;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            if (isDragging && selectedNode) {
                selectedNode.x = x - dragOffset.x;
                selectedNode.y = y - dragOffset.y;
            } else if (e.shiftKey && e.buttons === 1) {
                panOffset.x += e.movementX;
                panOffset.y += e.movementY;
            }
            
            // Update cursor
            let hovering = false;
            for (let node of currentMap.nodes) {
                if (node.isPointInside(x, y)) {
                    canvas.style.cursor = 'pointer';
                    hovering = true;
                    break;
                }
            }
            
            if (!hovering && !e.shiftKey) {
                canvas.style.cursor = currentTool === 'delete' ? 'crosshair' : 'default';
            } else if (e.shiftKey) {
                canvas.style.cursor = 'grab';
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                saveHistory();
                autoSave();
            }
            canvas.style.cursor = 'default';
        }

        function handleWheel(e) {
            e.preventDefault();
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom *= scaleFactor;
            zoom = Math.max(0.3, Math.min(3, zoom));
        }

        function handleKeyDown(e) {
            if (e.key === 'Delete' && selectedNode) {
                if (confirm(t('confirm.delete'))) {
                    currentMap.nodes = currentMap.nodes.filter(n => n !== selectedNode);
                    currentMap.connections = currentMap.connections.filter(
                        c => c.source !== selectedNode && c.target !== selectedNode
                    );
                    selectedNode = null;
                    closeProperties();
                    saveHistory();
                    autoSave();
                }
            } else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveMap();
            }
        }

        // ===============================
        // Map Management
        // ===============================
        function newMap() {
            if (currentMap.nodes.length > 0) {
                if (!confirm(t('confirm.new'))) {
                    return;
                }
            }
            
            currentMap = {
                id: 'map_' + Date.now(),
                title: t('app.title'),
                mode: 'grinde',
                nodes: [],
                connections: [],
                created: new Date().toISOString(),
                modified: new Date().toISOString()
            };
            
            // Add central node
            const centerX = canvas.width / 2 / zoom - panOffset.x / zoom;
            const centerY = canvas.height / 2 / zoom - panOffset.y / zoom;
            const centralNode = new Node(centerX, centerY, t('node.central'), 'central');
            currentMap.nodes.push(centralNode);
        }

        function saveMap() {
            const title = prompt(t('prompt.map.title'), currentMap.title);
            if (title) {
                currentMap.title = title;
                currentMap.modified = new Date().toISOString();
                
                // Convert to plain objects for storage
                const mapData = {
                    id: currentMap.id,
                    title: currentMap.title,
                    mode: currentMap.mode,
                    created: currentMap.created,
                    modified: currentMap.modified,
                    nodes: currentMap.nodes.map(n => ({
                        id: n.id,
                        x: n.x,
                        y: n.y,
                        text: n.text,
                        type: n.type,
                        size: n.size,
                        color: n.color,
                        textSize: n.textSize,
                        textColor: n.textColor,
                        shape: n.shape,
                        cornerRadius: n.cornerRadius,
                        rotation: n.rotation
                    })),
                    connections: currentMap.connections.map(c => ({
                        sourceId: c.source.id,
                        targetId: c.target.id,
                        type: c.type,
                        color: c.color,
                        text: c.text || ''
                    }))
                };
                
                // Save to localStorage
                const maps = JSON.parse(localStorage.getItem('mindmaps') || '{}');
                maps[currentMap.id] = mapData;
                localStorage.setItem('mindmaps', JSON.stringify(maps));
                
                showToast(t('toast.saved'), 'success');
                loadMapsList();
            }
        }

        function autoSave() {
            if (!autosaveEnabled) return;
            if (currentMap.id) {
                currentMap.modified = new Date().toISOString();
                
                const mapData = {
                    id: currentMap.id,
                    title: currentMap.title,
                    mode: currentMap.mode,
                    created: currentMap.created,
                    modified: currentMap.modified,
                    nodes: currentMap.nodes.map(n => ({
                        id: n.id,
                        x: n.x,
                        y: n.y,
                        text: n.text,
                        type: n.type,
                        size: n.size,
                        color: n.color,
                        textSize: n.textSize,
                        textColor: n.textColor,
                        shape: n.shape,
                        cornerRadius: n.cornerRadius,
                        rotation: n.rotation
                    })),
                    connections: currentMap.connections.map(c => ({
                        sourceId: c.source.id,
                        targetId: c.target.id,
                        type: c.type,
                        color: c.color,
                        text: c.text || ''
                    }))
                };
                
                const maps = JSON.parse(localStorage.getItem('mindmaps') || '{}');
                maps[currentMap.id] = mapData;
                localStorage.setItem('mindmaps', JSON.stringify(maps));
            }
        }

        function loadMapsList() {
            const maps = JSON.parse(localStorage.getItem('mindmaps') || '{}');
            const mapsList = document.getElementById('mapsList');
            
            if (Object.keys(maps).length === 0) {
                mapsList.innerHTML = '<p style="color: #999; font-size: 13px;">Aucune carte sauvegard√©e</p>';
                return;
            }
            
            mapsList.innerHTML = '';
            Object.values(maps).forEach(map => {
                const mapItem = document.createElement('div');
                mapItem.className = 'map-item';
                if (map.id === currentMap.id) {
                    mapItem.classList.add('active');
                }

                // Checkbox for bulk selection
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'map-checkbox';
                checkbox.style.marginRight = '8px';
                checkbox.dataset.mapId = map.id;

                const titleDiv = document.createElement('div');
                titleDiv.className = 'map-item-title';
                titleDiv.textContent = map.title;

                const metaDiv = document.createElement('div');
                metaDiv.className = 'map-item-meta';
                metaDiv.textContent = `${map.nodes?.length || 0} ${t('stat.nodes')} ‚Ä¢ ${map.mode}`;

                const delBtn = document.createElement('button');
                delBtn.className = 'btn';
                delBtn.style.padding = '4px 8px';
                delBtn.style.marginLeft = '8px';
                delBtn.title = 'Delete saved map';
                delBtn.textContent = 'üóëÔ∏è';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteSavedMap(map.id);
                };

                mapItem.appendChild(checkbox);
                mapItem.appendChild(titleDiv);
                mapItem.appendChild(metaDiv);
                mapItem.appendChild(delBtn);

                mapItem.onclick = () => loadMap(map.id);
                mapsList.appendChild(mapItem);
            });

            // Ensure deleteSelected button is enabled/disabled appropriately
            updateDeleteSelectedState();
        }

        function toggleSelectAll(checked) {
            document.querySelectorAll('.map-checkbox').forEach(cb => cb.checked = checked);
            updateDeleteSelectedState();
        }

        function updateDeleteSelectedState() {
            const any = Array.from(document.querySelectorAll('.map-checkbox')).some(cb => cb.checked);
            const btn = document.getElementById('deleteSelectedBtn');
            if (btn) btn.disabled = !any;
        }

        function deleteSelectedSavedMaps() {
            const checked = Array.from(document.querySelectorAll('.map-checkbox')).filter(cb => cb.checked);
            if (checked.length === 0) return;
            if (!confirm(`Delete ${checked.length} selected map(s)?`)) return;

            const maps = JSON.parse(localStorage.getItem('mindmaps') || '{}');
            checked.forEach(cb => {
                const id = cb.dataset.mapId;
                if (maps[id]) delete maps[id];
                // If current map is deleted, reset
                if (currentMap && currentMap.id === id) newMap();
            });
            localStorage.setItem('mindmaps', JSON.stringify(maps));
            showToast(t('toast.deleted'), 'success');
            loadMapsList();
        }

        function loadMap(mapId) {
            const maps = JSON.parse(localStorage.getItem('mindmaps') || '{}');
            const mapData = maps[mapId];
            
            if (mapData) {
                // Reconstruct nodes
                const nodeMap = {};
                currentMap.nodes = mapData.nodes.map(n => {
                    const node = new Node(n.x, n.y, n.text, n.type);
                    node.id = n.id;
                    node.size = n.size;
                    node.color = n.color;
                    node.textSize = n.textSize;
                    node.textColor = n.textColor;
                    node.shape = n.shape;
                    node.cornerRadius = n.cornerRadius;
                    node.rotation = n.rotation || 0;
                    nodeMap[n.id] = node;
                    return node;
                });
                
                // Reconstruct connections
                currentMap.connections = mapData.connections.map(c => {
                    const conn = new Connection(nodeMap[c.sourceId], nodeMap[c.targetId], c.type);
                    conn.color = c.color;
                    return conn;
                });
                
                currentMap.id = mapData.id;
                currentMap.title = mapData.title;
                currentMap.mode = mapData.mode;
                currentMap.created = mapData.created;
                currentMap.modified = mapData.modified;
                
                setMode(currentMap.mode);
                showToast(t('toast.loaded'), 'success');
                closeModal('loadModal');
                loadMapsList();
                saveHistory();
            }
        }

        function loadMapDialog() {
            const modal = document.getElementById('loadModal');
            const mapsList = document.getElementById('loadMapsList');
            const maps = JSON.parse(localStorage.getItem('mindmaps') || '{}');
            
            mapsList.innerHTML = '';
            Object.values(maps).forEach(map => {
                const mapItem = document.createElement('div');
                mapItem.style.padding = '10px';
                mapItem.style.marginBottom = '8px';
                mapItem.style.border = '1px solid #e5e7eb';
                mapItem.style.borderRadius = '8px';
                mapItem.style.cursor = 'pointer';

                const left = document.createElement('div');
                left.style.display = 'inline-block';
                left.style.verticalAlign = 'middle';
                left.innerHTML = `
                    <div style="font-weight: 600;">${map.title}</div>
                    <div style="font-size: 12px; color: #999;">
                        ${new Date(map.modified).toLocaleDateString()} ‚Ä¢ 
                        ${map.nodes?.length || 0} ${t('stat.nodes')}
                    </div>
                `;

                const delBtn = document.createElement('button');
                delBtn.className = 'btn';
                delBtn.style.float = 'right';
                delBtn.style.padding = '4px 8px';
                delBtn.textContent = 'üóëÔ∏è';
                delBtn.title = 'Delete saved map';
                delBtn.onclick = (e) => { e.stopPropagation(); deleteSavedMap(map.id); };

                mapItem.appendChild(left);
                mapItem.appendChild(delBtn);
                mapItem.onclick = () => loadMap(map.id);
                mapsList.appendChild(mapItem);
            });
            
            modal.classList.add('active');
        }

        function deleteSavedMap(mapId) {
            if (!confirm('Delete this saved map?')) return;
            const maps = JSON.parse(localStorage.getItem('mindmaps') || '{}');
            if (maps[mapId]) {
                delete maps[mapId];
                localStorage.setItem('mindmaps', JSON.stringify(maps));
                showToast(t('toast.deleted'), 'success');

                // If the deleted map is currently loaded, reset to a new map
                if (currentMap && currentMap.id === mapId) {
                    newMap();
                }

                // Refresh lists
                loadMapsList();
                const loadModal = document.getElementById('loadModal');
                if (loadModal && loadModal.classList.contains('active')) {
                    loadMapDialog();
                }
            }
        }

        function clearCanvas() {
            if (confirm(t('confirm.new'))) {
                currentMap.nodes = [];
                currentMap.connections = [];
                selectedNode = null;
                closeProperties();
                saveHistory();
                autoSave();
            }
        }

        function exportMap(format) {
            if (format === 'json') {
                const mapData = {
                    title: currentMap.title,
                    mode: currentMap.mode,
                    nodes: currentMap.nodes.map(n => ({
                        text: n.text,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        size: n.size,
                        color: n.color,
                        textSize: n.textSize,
                        textColor: n.textColor,
                        shape: n.shape,
                        cornerRadius: n.cornerRadius,
                        rotation: n.rotation
                    })),
                    connections: currentMap.connections.map(c => ({
                        sourceId: c.source.id,
                        targetId: c.target.id,
                        type: c.type,
                        text: c.text || ''
                    }))
                };
                
                const dataStr = JSON.stringify(mapData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = currentMap.title + '.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                showToast(t('toast.exported'), 'success');
            }
        }

        function loadTemplate(templateId) {
            const template = templates[templateId];
            if (template) {
                currentMap.title = template.title;
                currentMap.mode = template.mode;
                currentMap.nodes = [];
                currentMap.connections = [];
                selectedNode = null; // Clear selection when loading template
                
                // Create nodes from template
                template.nodes.forEach(nodeData => {
                    const node = new Node(nodeData.x, nodeData.y, nodeData.text, nodeData.type);
                    currentMap.nodes.push(node);
                });
                
                // Connect to central if exists
                const central = currentMap.nodes.find(n => n.type === 'central');
                if (central) {
                    currentMap.nodes.forEach(node => {
                        if (node !== central && node.type === 'group') {
                            currentMap.connections.push(new Connection(central, node));
                        }
                    });
                    // Select the central node by default for easy addition of new nodes
                    selectedNode = central;
                    showProperties(central);
                }
                
                setMode(currentMap.mode);
                showToast(t('toast.loaded'), 'success');
                saveHistory();
            }
        }

        // ===============================
        // Node Management
        // ===============================
        function addNode(type) {
            // Show inline quick-add form for better UX
            showQuickAddForType(type);
        }

        function toggleToolbox() {
            // toolbox removed; no-op
            return;
        }

        function showQuickAddForType(type) {
            const quick = document.getElementById('quickAdd');
            const txt = document.getElementById('quickAddText');
            if (!quick || !txt) return;
            quick.dataset.type = type;
            txt.value = '';
            quick.style.display = 'block';
            txt.focus();
        }

        function addNodeFromQuickAdd() {
            const quick = document.getElementById('quickAdd');
            const txt = document.getElementById('quickAddText');
            if (!quick || !txt) return;
            const type = quick.dataset.type || 'concept';
            const text = txt.value.trim() || t('prompt.node.text') + '...';

            // compute location
            let nodeX, nodeY;
            if (selectedNode && type !== 'central') {
                const angle = Math.random() * 2 * Math.PI;
                const distance = 120 + Math.random() * 80;
                nodeX = selectedNode.x + Math.cos(angle) * distance;
                nodeY = selectedNode.y + Math.sin(angle) * distance;
            } else {
                const centerX = canvas.width / 2 / zoom - panOffset.x / zoom;
                const centerY = canvas.height / 2 / zoom - panOffset.y / zoom;
                nodeX = centerX + Math.random() * 100 - 50;
                nodeY = centerY + Math.random() * 100 - 50;
            }

            const node = new Node(nodeX, nodeY, text, type);
            currentMap.nodes.push(node);
            if (type !== 'central') {
                let parentNode = selectedNode || currentMap.nodes.find(n => n.type === 'central');
                if (parentNode) currentMap.connections.push(new Connection(parentNode, node));
            }
            saveHistory();
            autoSave();
            hideQuickAdd();
        }

        function hideQuickAdd() {
            const quick = document.getElementById('quickAdd');
            if (!quick) return;
            quick.style.display = 'none';
        }

        // ===============================
        // Properties Panel
        // ===============================
        function showProperties(node) {
            const panel = document.getElementById('propertiesPanel');
            panel.classList.add('active');
            // Use an editing buffer so Cancel can discard changes
            editingNode = Object.assign({}, node);

            document.getElementById('nodeText').value = editingNode.text;
            document.getElementById('nodeTextSize').value = editingNode.textSize || Math.round(editingNode.size * 0.7);
            document.getElementById('nodeSize').value = editingNode.size;
            document.getElementById('nodeTextColor').value = editingNode.textColor || '#ffffff';
            document.getElementById('nodeColor').value = editingNode.color || '#6366f1';
            document.getElementById('nodeShape').value = editingNode.shape || 'rounded';
            document.getElementById('nodeCornerRadius').value = editingNode.cornerRadius || 8;
            // initial preview
            drawPreview(editingNode);
            selectedNode = node; // store reference to the original until saved
        }
        function closeProperties() {
            document.getElementById('propertiesPanel').classList.remove('active');
            editingNode = null;
            selectedNode = null;
        }

        function updateNodeProperty(property) {
            if (!editingNode) return;
            if (property === 'text') {
                editingNode.text = document.getElementById('nodeText').value;
            } else if (property === 'size') {
                editingNode.size = parseInt(document.getElementById('nodeSize').value);
            } else if (property === 'textSize') {
                editingNode.textSize = parseInt(document.getElementById('nodeTextSize').value);
            } else if (property === 'textColor') {
                editingNode.textColor = document.getElementById('nodeTextColor').value;
            } else if (property === 'color') {
                editingNode.color = document.getElementById('nodeColor').value;
            } else if (property === 'shape') {
                editingNode.shape = document.getElementById('nodeShape').value;
            } else if (property === 'cornerRadius') {
                editingNode.cornerRadius = parseInt(document.getElementById('nodeCornerRadius').value);
            } else if (property === 'rotation') {
                editingNode.rotation = parseInt(document.getElementById('nodeRotation').value);
            }
            // live preview: apply to selectedNode visually but don't persist until Save
            if (selectedNode && editingNode) {
                // copy preview properties
                selectedNode.text = editingNode.text;
                selectedNode.size = editingNode.size;
                selectedNode.textSize = editingNode.textSize;
                selectedNode.textColor = editingNode.textColor;
                selectedNode.color = editingNode.color;
                selectedNode.shape = editingNode.shape;
                selectedNode.cornerRadius = editingNode.cornerRadius || 8;
                selectedNode.rotation = editingNode.rotation || 0;
                // update preview canvas
                drawPreview(editingNode);
            }
        }

        function setNodeColor(color, el) {
            if (!editingNode) return;
            editingNode.color = color;
            document.getElementById('nodeColor').value = color;
            document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
            if (el && el.classList) el.classList.add('selected');
            updateNodeProperty('color');
        }

        function saveProperties() {
            if (!selectedNode || !editingNode) return;
            // apply all editingNode properties to the actual node
            selectedNode.text = editingNode.text;
            selectedNode.size = editingNode.size;
            selectedNode.textSize = editingNode.textSize;
            selectedNode.textColor = editingNode.textColor;
            selectedNode.color = editingNode.color;
            selectedNode.shape = editingNode.shape;
            selectedNode.cornerRadius = editingNode.cornerRadius || 8;

            editingNode = null;
            closeProperties();
            saveHistory();
            autoSave();
        }

        function cancelProperties() {
            // revert preview by reloading node from stored map (reload by id)
            if (selectedNode && selectedNode.id) {
                const orig = currentMap.nodes.find(n => n.id === selectedNode.id);
                if (orig) {
                    // restore original properties
                    selectedNode.text = orig.text;
                    selectedNode.size = orig.size;
                    selectedNode.textSize = orig.textSize;
                    selectedNode.textColor = orig.textColor;
                    selectedNode.color = orig.color;
                    selectedNode.shape = orig.shape;
                        selectedNode.cornerRadius = orig.cornerRadius;
                        selectedNode.rotation = orig.rotation || 0;
                }
            }
            editingNode = null;
            closeProperties();
        }

        // Arrow properties functions
        function showArrowPropertiesPanel(connection) {
            selectedConnection = connection;
            const panel = document.getElementById('arrowPropertiesPanel');
            panel.classList.add('active');
            document.getElementById('arrowId').value = connection.id;
            document.getElementById('arrowText').value = connection.text || '';
        }

        function closeArrowPropertiesPanel() {
            const panel = document.getElementById('arrowPropertiesPanel');
            panel.classList.remove('active');
            selectedConnection = null;
        }

        function saveArrowProperties() {
            if (!selectedConnection) return;
            selectedConnection.text = document.getElementById('arrowText').value;
            closeArrowPropertiesPanel();
            saveHistory();
            autoSave();
            showToast(t('toast.saved'), 'success');
        }

        function cancelArrowProperties() {
            closeArrowPropertiesPanel();
        }

        // -------------------------------
        // Preview rendering inside properties panel
        // -------------------------------
        function drawPreview(node) {
            const cvs = document.getElementById('propPreview');
            if (!cvs || !node) return;
            const cctx = cvs.getContext('2d');
            cctx.clearRect(0,0,cvs.width,cvs.height);
            // Draw a small representation centered
            const x = cvs.width / 2;
            const y = cvs.height / 2;
            const temp = new Node(x, y, node.text || 'Text', node.type || 'concept');
            // copy properties
            temp.size = node.size || 30;
            temp.color = node.color || '#6366f1';
            temp.textSize = node.textSize || Math.round(temp.size * 0.7);
            temp.textColor = node.textColor || '#ffffff';
            temp.shape = node.shape || 'rounded';
            temp.cornerRadius = node.cornerRadius || 8;
            // override draw to use provided context
            temp.draw(cctx);
        }

        // -------------------------------
        // Simple history (serialize currentMap)
        // -------------------------------
        function snapshot() {
            return JSON.stringify({ nodes: currentMap.nodes.map(n => ({ id:n.id, x:n.x,y:n.y,text:n.text,type:n.type,size:n.size,color:n.color,textSize:n.textSize,textColor:n.textColor,shape:n.shape,cornerRadius:n.cornerRadius })), connections: currentMap.connections.map(c=>({sourceId:c.source.id,targetId:c.target.id,type:c.type,color:c.color,text:c.text || ''})) });
        }

        function saveHistory() {
            const snap = snapshot();
            // truncate future
            history = history.slice(0, historyIndex + 1);
            history.push(snap);
            historyIndex = history.length - 1;
        }

        function restoreFromSnapshot(snap) {
            try {
                const data = JSON.parse(snap);
                const nodeMap = {};
                currentMap.nodes = data.nodes.map(n => {
                    const node = new Node(n.x, n.y, n.text, n.type);
                    node.id = n.id;
                    node.size = n.size;
                    node.color = n.color;
                    node.textSize = n.textSize;
                    node.textColor = n.textColor;
                    node.shape = n.shape;
                    node.cornerRadius = n.cornerRadius;
                    node.rotation = n.rotation || 0;
                    nodeMap[n.id] = node;
                    return node;
                });
                currentMap.connections = data.connections.map(c => new Connection(nodeMap[c.sourceId], nodeMap[c.targetId], c.type));
                // restore text labels
                currentMap.connections.forEach((conn, idx) => {
                    if (data.connections[idx] && data.connections[idx].text) conn.text = data.connections[idx].text;
                });
            } catch (err) {
                console.error('Failed to restore snapshot', err);
            }
        }

        function undo() {
            if (historyIndex <= 0) return;
            historyIndex--;
            restoreFromSnapshot(history[historyIndex]);
        }

        function redo() {
            if (historyIndex >= history.length - 1) return;
            historyIndex++;
            restoreFromSnapshot(history[historyIndex]);
        }

        // ===============================
        // UI Controls
        // ===============================
        function setMode(mode) {
            // Only Buzan mode is supported now
            currentMap.mode = 'buzan';
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            const btn = document.querySelector('.mode-btn.buzan');
            if (btn) btn.classList.add('active');
            document.getElementById('currentMode').textContent = 'BUZAN';
        }

        function openGuide() {
            document.getElementById('guideModal').classList.add('active');
        }

        function toggleAutosave(enabled) {
            autosaveEnabled = !!enabled;
            const el = document.getElementById('autosaveToggle');
            if (el) el.checked = autosaveEnabled;
        }

        function setTool(tool) {
            currentTool = tool;
            isConnecting = false;
            connectStart = null;
            canvas.style.cursor = tool === 'delete' ? 'crosshair' : 'default';
            // Toggle active class on toolbar buttons
            document.querySelectorAll('.toolbar .tool-group .btn').forEach(btn => btn.classList.remove('active'));
            // find a button whose onclick contains the tool name (best-effort)
            const btns = Array.from(document.querySelectorAll('.toolbar .btn'));
            for (let b of btns) {
                const on = b.getAttribute('onclick') || '';
                if (on.includes(`setTool('${tool}')`) || on.includes(`setTool("${tool}")`)) { b.classList.add('active'); break; }
            }
        }

        function zoomIn() {
            zoom = Math.min(zoom * 1.2, 3);
        }

        function zoomOut() {
            zoom = Math.max(zoom * 0.8, 0.3);
        }

        function resetView() {
            zoom = 1;
            panOffset = { x: 0, y: 0 };
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('hidden');
        }

        function showSidebarTab(tab) {
            document.querySelectorAll('.sidebar-pane').forEach(pane => {
                pane.style.display = 'none';
            });
            document.getElementById(`${tab}-tab`).style.display = 'block';
            
            document.querySelectorAll('.sidebar-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function updateStats() {
            document.getElementById('nodeCount').textContent = currentMap.nodes.length;
            document.getElementById('connectionCount').textContent = currentMap.connections.length;
        }

        // ===============================
        // Language Management
        // ===============================
        function setLanguage(lang) {
            currentLanguage = lang;
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.lang-btn.${lang}`).classList.add('active');
            
            // Update all texts
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (i18n[lang][key]) {
                    element.textContent = i18n[lang][key];
                }
            });

            // Populate job aid / help content if present
            const jobAidEl = document.getElementById('jobAid');
            if (jobAidEl && i18n[lang] && i18n[lang]['jobaid.lines']) {
                const lines = i18n[lang]['jobaid.lines'];
                jobAidEl.innerHTML = '';
                lines.forEach(line => {
                    if (line === '') {
                        jobAidEl.appendChild(document.createElement('br'));
                    } else {
                        const p = document.createElement('p');
                        p.style.marginBottom = '8px';
                        p.textContent = line;
                        jobAidEl.appendChild(p);
                    }
                });
            }
            
            localStorage.setItem('language', lang);
            // set property panel button labels
            const saveBtn = document.getElementById('propSaveBtn');
            const cancelBtn = document.getElementById('propCancelBtn');
            if (saveBtn) saveBtn.textContent = i18n[lang]['prop.save'] || 'Save';
            if (cancelBtn) cancelBtn.textContent = i18n[lang]['prop.cancel'] || 'Cancel';
            // set guide static bits if present
            const guideLabel = document.getElementById('guideLabel');
            if (guideLabel) guideLabel.textContent = i18n[lang]['sidebar.guides'] || 'Guide';
        }

        function toggleGuide(id) {
            const body = document.getElementById(`guide-${id}-body`);
            if (!body) return;
            body.style.display = body.style.display === 'none' ? 'block' : 'none';
        }

        function t(key) {
            return i18n[currentLanguage][key] || key;
        }

        // ===============================
        // Toast Notifications
        // ===============================
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ===============================
        // Initialize on load
        // ===============================
        window.addEventListener('load', init);
    </script>
</body>
</html>
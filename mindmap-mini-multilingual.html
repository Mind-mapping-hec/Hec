<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Mini - Outil de Cartographie Mentale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
            --grinde: #8b5cf6;
            --buzan: #06b6d4;
            --french: #002395;
            --english: #012169;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.98);
            padding: 0.8rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--primary);
        }

        .autosave-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 20px;
            font-size: 0.85rem;
        }

        .autosave-label {
            color: #4b5563;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #4f46e5;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .mode-toggle {
            display: flex;
            background: var(--light);
            padding: 4px;
            border-radius: 8px;
            gap: 4px;
        }

        .mode-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            background: transparent;
            transition: all 0.3s;
            font-size: 13px;
        }

        .mode-btn.active {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .mode-btn.grinde.active {
            color: var(--grinde);
        }

        .mode-btn.buzan.active {
            color: var(--buzan);
        }

        /* Language Switcher */
        .language-switcher {
            display: flex;
            background: var(--light);
            padding: 3px;
            border-radius: 8px;
            gap: 2px;
        }

        .lang-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            background: transparent;
            transition: all 0.3s;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .lang-btn.active {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .lang-btn.fr.active {
            color: var(--french);
        }

        .lang-btn.en.active {
            color: var(--english);
        }

        .flag {
            width: 16px;
            height: 12px;
            display: inline-block;
        }

        /* Toolbar */
        .toolbar {
            background: white;
            padding: 0;
            display: flex;
            border-bottom: 1px solid var(--light);
            align-items: stretch;
        }

        .menu-bar {
            display: flex;
            align-items: stretch;
        }

        .menu-item {
            position: relative;
            display: flex;
            align-items: center;
        }

        .menu-button {
            padding: 12px 16px;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--dark);
            transition: all 0.2s;
            border-right: 1px solid var(--light);
        }

        .menu-button:hover {
            background: var(--primary);
            color: white;
        }

        .menu-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid var(--light);
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            min-width: 180px;
            z-index: 1000;
        }

        .menu-item:hover .menu-dropdown {
            display: block;
        }

        .menu-dropdown-item {
            padding: 10px 16px;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            text-align: left;
            transition: all 0.2s;
            border-bottom: 1px solid #f3f4f6;
        }

        .menu-dropdown-item:last-child {
            border-bottom: none;
        }

        .menu-dropdown-item:hover {
            background: var(--primary);
            color: white;
        }

        .toggle-checkmark {
            color: #10b981;
            font-weight: bold;
            font-size: 0.9em;
            margin-right: 0.3em;
            opacity: 1;
            transition: opacity 0.2s ease;
        }

        .toggle-checkmark.hidden {
            opacity: 0;
        }

        .tool-group {
            display: flex;
            gap: 0.5rem;
            padding: 0.8rem;
            border-right: 2px solid var(--light);
            align-items: center;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-group-label {
            font-size: 11px;
            color: #9ca3af;
            text-transform: uppercase;
            font-weight: 600;
            margin-right: 4px;
        }

        /* Specialized styling for nodes tool-group */
        .tool-group.nodes-group {
            justify-content: center;
            flex: 0 0 auto;
            max-width: 500px;
            margin: 0 8px 0 auto;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 12px;
            border: 2px solid #cbd5e0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .tool-group.nodes-group .tool-group-label {
            color: #4a5568;
            font-weight: 700;
            font-size: 12px;
            margin-right: 12px;
        }

        .tool-group.nodes-group .btn {
            background: linear-gradient(135deg, #ffffff 0%, #f7fafc 100%);
            border: 2px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            font-weight: 600;
        }

        .tool-group.nodes-group .btn:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
            border-color: #cbd5e0;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        /* Specialized styling for arrows tool-group */
        .tool-group.arrows-group {
            justify-content: center;
            flex: 0 0 auto;
            max-width: 160px;
            min-width: 140px;
            margin: 0 auto 0 8px;
            padding: 1rem 1.2rem;
            background: linear-gradient(135deg, #f0f9ff 0%, #dbeafe 100%);
            border-radius: 12px;
            border: 2px solid #bfdbfe;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.1);
        }

        .tool-group.arrows-group .tool-group-label {
            color: #1e40af;
            font-weight: 700;
            font-size: 12px;
            margin-right: 12px;
        }

        .tool-group.arrows-group .btn {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border: 2px solid #bfdbfe;
            box-shadow: 0 1px 3px rgba(59, 130, 246, 0.1);
            font-weight: 600;
            margin: 0 2px;
            min-width: 70px;
        }

        .tool-group.arrows-group .btn:hover {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border-color: #93c5fd;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(59, 130, 246, 0.15);
        }

        .btn {
            padding: 6px 12px;
            border: 2px solid var(--light);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }

        .btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .btn-success {
            background: var(--secondary);
            color: white;
            border-color: var(--secondary);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        /* Main Layout */
        .main-container {
            display: flex;
            height: calc(100vh - 120px);
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid var(--light);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
            margin-right: -280px;
        }

        .hidden {
            display: none !important;
        }

        .sidebar-tabs {
            display: flex;
            background: var(--light);
            border-bottom: 1px solid #e5e7eb;
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            transition: all 0.2s;
        }

        .sidebar-tab.active {
            background: white;
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
        }

        .sidebar-section {
            padding: 1rem;
            border-bottom: 1px solid var(--light);
        }

        .sidebar-title {
            font-weight: 600;
            margin-bottom: 0.8rem;
            color: var(--dark);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .map-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .map-item {
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            position: relative;
        }

        .map-item:hover {
            background: var(--light);
            border-color: var(--primary);
        }

        .map-item.active {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
        }

        .map-item-title {
            font-weight: 500;
            font-size: 14px;
        }

        .map-item-meta {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 4px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .map-date {
            font-size: 10px;
            opacity: 0.6;
            color: #6b7280;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .map-item-actions {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            display: none;
            gap: 4px;
            align-items: center;
        }

        .map-item:hover .map-item-actions {
            display: flex;
        }

        .map-action-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
        }

        .map-action-btn:hover {
            background: white;
            transform: scale(1.1);
        }

        .map-action-btn.rename {
            color: #3b82f6;
        }

        .map-action-btn.delete {
            color: #ef4444;
        }

        .map-action-btn.rename:hover {
            background: #eff6ff;
            border-color: #3b82f6;
        }

        .map-action-btn.delete:hover {
            background: #fef2f2;
            border-color: #ef4444;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .template-card {
            padding: 12px;
            border: 2px solid var(--light);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .template-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .template-icon {
            font-size: 1.8rem;
            margin-bottom: 4px;
        }

        .template-name {
            font-weight: 600;
            font-size: 12px;
        }

        /* Right Panel */
        .right-panel {
            width: 320px;
            background: white;
            border-left: 1px solid var(--light);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s;
            position: absolute;
            right: 0;
            top: 180px;
            bottom: 0;
            z-index: 10;
        }

        .right-panel.hidden {
            transform: translateX(100%);
        }

        .no-selection-message {
            color: #6b7280;
            font-style: italic;
            text-align: center;
            padding: 20px;
            font-size: 14px;
        }

        /* Canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            background: white;
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
            background-image: 
                radial-gradient(circle at 1px 1px, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        /* Floating Panels */
        .float-panel {
            position: absolute;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 1rem;
            z-index: 100;
        }

        .properties-panel {
            right: 20px;
            top: 20px;
            width: 240px;
            display: none;
        }

        .properties-panel.active {
            display: block;
        }

        .panel-header {
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--dark);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .panel-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .panel-close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        .property-group {
            margin-bottom: 1rem;
        }

        .property-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 4px;
        }

        .property-input {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--light);
            border-radius: 4px;
            font-size: 13px;
        }

        .property-input select {
            background: white;
            cursor: pointer;
        }

        .property-input select option {
            padding: 4px;
        }

        .size-display-container {
            position: relative;
        }

        .size-value-display {
            display: block;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            color: #3b82f6;
            margin-bottom: 4px;
            background: #f0f9ff;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #bfdbfe;
        }

        .shape-size-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .shape-size-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .shape-size-label {
            font-size: 11px;
            font-weight: 600;
            color: #374151;
            min-width: 70px;
        }

        .shape-size-value {
            font-weight: bold;
            font-size: 12px;
            color: #059669;
            min-width: 30px;
            text-align: center;
            background: #f0fdf4;
            padding: 1px 6px;
            border-radius: 3px;
            border: 1px solid #bbf7d0;
        }

        .shape-size-slider {
            flex: 1;
            margin: 0;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: var(--dark);
            box-shadow: 0 0 0 2px white, 0 0 0 4px var(--dark);
        }

        /* Property Buttons */
        .property-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid var(--light);
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .btn-primary:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        /* Stats */
        .stats-panel {
            left: 20px;
            bottom: 20px;
            display: flex;
            gap: 1.2rem;
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }

        .stat-label {
            font-size: 11px;
            color: var(--dark);
            opacity: 0.7;
            text-transform: uppercase;
        }

        /* Score Modal Styles */
        .score-content {
            max-height: 70vh;
            overflow-y: auto;
        }

        .score-metrics {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .score-card {
            text-align: center;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 1rem;
        }

        .score-card h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .score-value {
            font-size: 3rem;
            font-weight: 700;
            margin: 0.5rem 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .score-description {
            font-size: 1.1rem;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .score-details {
            background: #f8fafc;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .score-item {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
        }

        .score-item:last-child {
            margin-bottom: 0;
        }

        .score-item span:first-child {
            min-width: 100px;
            font-weight: 600;
            color: #374151;
        }

        .score-bar {
            flex: 1;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }

        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .score-number {
            min-width: 45px;
            text-align: right;
            font-weight: 600;
            color: #059669;
        }

        .score-analysis {
            background: #ffffff;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .score-analysis h4 {
            margin: 0 0 1rem 0;
            color: #1f2937;
            font-size: 1.1rem;
        }

        .analysis-text p {
            margin: 0 0 0.5rem 0;
            font-weight: 600;
            color: #374151;
        }

        .analysis-text ul {
            margin: 0.5rem 0 1rem 1rem;
            padding: 0;
        }

        .analysis-text li {
            margin-bottom: 0.3rem;
            color: #6b7280;
            line-height: 1.5;
        }

        /* Quick Actions */
        .quick-actions {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            z-index: 100;
        }

        .fab {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(99, 102, 241, 0.3);
            transition: all 0.3s;
            font-size: 20px;
        }

        .fab:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .fab-menu {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 8px;
            display: none;
            min-width: 150px;
            z-index: 200;
        }

        .fab-menu.active {
            display: block;
        }

        .fab-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.2s;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fab-menu-item:hover {
            background: var(--light);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 16px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--dark);
        }

        .close-btn {
            font-size: 1.5rem;
            cursor: pointer;
            background: none;
            border: none;
            color: var(--dark);
            opacity: 0.5;
            transition: opacity 0.2s;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
        }

        .close-btn:hover {
            opacity: 1;
            background: var(--light);
        }

        /* Guide Cards */
        .guide-section {
            margin-bottom: 1.5rem;
        }

        .guide-section h3 {
            color: var(--primary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .guide-card {
            background: var(--light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.8rem;
            border-left: 4px solid var(--primary);
        }

        .guide-card.grinde {
            border-left-color: var(--grinde);
        }

        .guide-card.buzan {
            border-left-color: var(--buzan);
        }

        .guide-card h4 {
            margin-bottom: 0.5rem;
            color: var(--dark);
        }

        .guide-card p {
            font-size: 14px;
            line-height: 1.5;
            color: #6b7280;
        }

        /* Maps Grid */
        .maps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .map-item {
            background: var(--light);
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .map-item:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .map-title {
            font-weight: bold;
            color: var(--dark);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .map-date {
            color: #6b7280;
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
        }

        .map-nodes {
            color: var(--primary);
            font-size: 0.85rem;
            font-weight: 500;
        }

        /* Shortcuts Table */
        .shortcuts-table {
            width: 100%;
            font-size: 14px;
            border-collapse: collapse;
        }

        .shortcuts-table td {
            padding: 8px;
            border-bottom: 1px solid var(--light);
        }

        .shortcuts-table td:first-child {
            font-family: monospace;
            background: var(--light);
            border-radius: 4px;
            text-align: center;
            font-weight: 600;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: var(--dark);
            color: white;
            border-radius: 8px;
            font-size: 14px;
            z-index: 2000;
            animation: slideUp 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .toast.success {
            background: var(--secondary);
        }

        .toast.error {
            background: var(--danger);
        }

        .toast.warning {
            background: var(--warning);
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                z-index: 50;
                height: 100%;
            }
            
            .toolbar {
                overflow-x: auto;
            }
            
            .menu-dropdown {
                position: fixed;
                top: 60px;
                left: 0;
                right: 0;
                border-radius: 0;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            }
            
            .header-center {
                flex-direction: column;
                gap: 8px;
            }
            
            .tool-group-label {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <span>üß†</span>
            <span data-i18n="app.title">Mind Map Mini</span>
            <div class="autosave-toggle">
                <span class="autosave-label" data-i18n="autosave.label">AutoSave</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="autosaveToggle" aria-label="Auto save" title="AutoSave" checked onchange="toggleAutoSave()">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <div class="header-center">
            <div class="mode-toggle">
                <button class="mode-btn grinde active" onclick="setMode('grinde')">
                    <span data-i18n="mode.grinde">GRINDE</span>
                </button>
                <button class="mode-btn buzan" onclick="setMode('buzan')">
                    <span data-i18n="mode.buzan">Buzan</span>
                </button>
            </div>
            
            <div class="language-switcher">
                <button class="lang-btn fr active" onclick="setLanguage('fr')">
                    <span class="flag">üá´üá∑</span>
                    <span>FR</span>
                </button>
                <button class="lang-btn en" onclick="setLanguage('en')">
                    <span class="flag">üá¨üáß</span>
                    <span>EN</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <div class="menu-bar">
            <div class="menu-item">
                <button class="menu-button" data-i18n="toolbar.file">Fichier</button>
                <div class="menu-dropdown">
                    <button class="menu-dropdown-item" onclick="saveMap()">
                        üíæ <span data-i18n="btn.save">Sauvegarder</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="newMap()">
                        üìÑ <span data-i18n="btn.new">Nouveau</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="loadMapDialog()">
                        üìÅ <span data-i18n="btn.open">Ouvrir</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="duplicateMap()">
                        üìã <span data-i18n="btn.duplicate">Dupliquer</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="closeMap()">
                        ‚úñÔ∏è <span data-i18n="btn.close">Fermer</span>
                    </button>
                </div>
            </div>
            
            <div class="menu-item">
                <button class="menu-button" data-i18n="toolbar.edit">Edition</button>
                <div class="menu-dropdown">
                    <button class="menu-dropdown-item" onclick="undo()">
                        ‚Ü©Ô∏è <span data-i18n="btn.undo">Annuler</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="redo()">
                        ‚Ü™Ô∏è <span data-i18n="btn.redo">Refaire</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="setTool('connect')">
                        üîó <span data-i18n="btn.connect">Connecter</span>
                    </button>
                </div>
            </div>
            
            <div class="menu-item">
                <button class="menu-button" data-i18n="toolbar.view">Affichage</button>
                <div class="menu-dropdown">
                    <button class="menu-dropdown-item" id="sidebarToggle" onclick="toggleSidebar()">
                        üìä <span id="sidebarCheckmark" class="toggle-checkmark">‚úì</span> <span data-i18n="btn.sidebar">Panneau gauche</span>
                    </button>
                    <button class="menu-dropdown-item" id="rightPanelToggle" onclick="toggleRightPanel()">
                        üìã <span id="rightPanelCheckmark" class="toggle-checkmark">‚úì</span> <span data-i18n="btn.rightpanel">Panneau droit</span>
                    </button>
                    <button class="menu-dropdown-item" id="toolsToggle" onclick="toggleTools()">
                        üõ†Ô∏è <span id="toolsCheckmark" class="toggle-checkmark">‚úì</span> <span data-i18n="btn.tools">Panneau OUTILS</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="zoomIn()">
                        üîç+ <span data-i18n="btn.zoomIn">Zoom +</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="zoomOut()">
                        üîç- <span data-i18n="btn.zoomOut">Zoom -</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="resetView()">
                        üîÑ <span data-i18n="btn.reset">R√©initialiser</span>
                    </button>
                </div>
            </div>
            
            <div class="menu-item">
                <button class="menu-button" data-i18n="toolbar.export">Export</button>
                <div class="menu-dropdown">
                    <button class="menu-dropdown-item" onclick="exportMap('json')">
                        üì§ JSON
                    </button>
                    <button class="menu-dropdown-item" onclick="exportMap('markdown')">
                        üìù Markdown
                    </button>
                    <button class="menu-dropdown-item" onclick="exportMap('html')">
                        üåê HTML
                    </button>
                </div>
            </div>
            
            <div class="menu-item">
                <button class="menu-button" data-i18n="toolbar.score">Score</button>
                <div class="menu-dropdown">
                    <button class="menu-dropdown-item" onclick="showScoreModal()">
                        üìä <span data-i18n="score.analysis">Analyse</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="showScoreDetails()">
                        üìà <span data-i18n="score.details">D√©tails</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="exportScoreReport()">
                        üìã <span data-i18n="score.report">Rapport</span>
                    </button>
                </div>
            </div>
            
            <div class="menu-item">
                <button class="menu-button" data-i18n="toolbar.guide">Guide</button>
                <div class="menu-dropdown">
                    <button class="menu-dropdown-item" onclick="showGuideModal()">
                        üìñ <span data-i18n="guide.quick">Guide Rapide</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="showTemplatesModal()">
                        üìã <span data-i18n="guide.templates">Mod√®les</span>
                    </button>
                    <button class="menu-dropdown-item" onclick="showShortcutsModal()">
                        ‚å®Ô∏è <span data-i18n="guide.shortcuts">Raccourcis</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="tool-group tools-group" id="toolsContainer">
            <span class="tool-group-label" data-i18n="toolbar.tools">Outils</span>
            <button class="btn tool-btn" id="lassoTool" onclick="setToolFromContainer('lasso')" title="Lasso">
                <span class="tool-icon">‚≠ï</span>
            </button>
            <button class="btn tool-btn" id="eraserTool" onclick="setToolFromContainer('eraser')" title="Gomme">
                <span class="tool-icon">üßΩ</span>
            </button>
            <button class="btn tool-btn" id="penTool" onclick="setToolFromContainer('pen')" title="Stylo">
                <span class="tool-icon">‚úèÔ∏è</span>
            </button>
            <button class="btn tool-btn" id="pencilTool" onclick="setToolFromContainer('pencil')" title="Crayon">
                <span class="tool-icon">‚úé</span>
            </button>
            <div class="tool-row">
                <div class="size-chooser" id="sizeChooser">
                    <button class="size-btn" data-size="1" title="Taille 1">1</button>
                    <button class="size-btn" data-size="2" title="Taille 2">2</button>
                    <button class="size-btn" data-size="4" title="Taille 4">4</button>
                    <button class="size-btn" data-size="6" title="Taille 6">6</button>
                    <button class="size-btn" data-size="8" title="Taille 8">8</button>
                    <button class="size-btn" data-size="10" title="Taille 10">10</button>
                    <button class="size-btn" data-size="12" title="Taille 12">12</button>
                    <button class="size-btn" data-size="15" title="Taille 15">15</button>
                    <button class="size-btn" data-size="20" title="Taille 20">20</button>
                </div>
                <div class="color-chooser" id="colorChooser">
                    <button class="color-btn" data-color="#ff69b4" style="background-color: #ff69b4;" title="Rose"></button>
                    <button class="color-btn" data-color="#ffa500" style="background-color: #ffa500;" title="Orange"></button>
                    <button class="color-btn" data-color="#32cd32" style="background-color: #32cd32;" title="Vert"></button>
                    <button class="color-btn" data-color="#1e90ff" style="background-color: #1e90ff;" title="Bleu"></button>
                    <button class="color-btn" data-color="#ffffff" style="background-color: #ffffff; border: 1px solid #ccc;" title="Blanc"></button>
                </div>
            </div>
        </div>
        
        <!-- Quick Actions -->
        <div class="quick-actions">
            <div class="fab-menu" id="fabMenu">
                <div class="fab-menu-item" onclick="quickAddNode('concept')">
                    üí° <span data-i18n="quick.concept">Concept</span>
                </div>
                <div class="fab-menu-item" onclick="quickAddNode('group')">
                    üì¶ <span data-i18n="quick.group">Groupe</span>
                </div>
                <div class="fab-menu-item" onclick="quickAddNode('detail')">
                    üìù <span data-i18n="quick.detail">D√©tail</span>
                </div>
            </div>
            <button class="fab" onclick="toggleFabMenu()">+</button>
        </div>
        
        <div class="tool-group nodes-group">
            <span class="tool-group-label" data-i18n="toolbar.nodes">N≈ìuds</span>
            <button class="btn" onclick="addNode('central')">
                ‚≠ê <span data-i18n="node.central">Central</span>
            </button>
            <button class="btn" onclick="addNode('group')">
                üì¶ <span data-i18n="node.group">Groupe</span>
            </button>
            <button class="btn" onclick="addNode('concept')">
                üí° <span data-i18n="node.concept">Concept</span>
            </button>
            <button class="btn" onclick="addNode('detail')">
                üìù <span data-i18n="node.detail">D√©tail</span>
            </button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-tabs">
                <button class="sidebar-tab" onclick="showSidebarTab('principles')">
                    <span data-i18n="sidebar.principles">Principes Actifs</span>
                </button>
                <button class="sidebar-tab active" onclick="showSidebarTab('maps')">
                    <span data-i18n="sidebar.maps">Mes Cartes</span>
                </button>
                <button class="sidebar-tab" onclick="showSidebarTab('templates')">
                    <span data-i18n="sidebar.templates">Mod√®les</span>
                </button>
                <button class="sidebar-tab" onclick="showSidebarTab('help')">
                    <span data-i18n="sidebar.help">Aide</span>
                </button>
            </div>
            
            <div class="sidebar-content">
                <!-- Principles Tab -->
                <div id="principles-tab" class="sidebar-pane" style="display: none;">
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            üéØ <span data-i18n="sidebar.principles">Principes Actifs</span>
                        </div>
                        <div id="principles-list">
                            <!-- Principles will be loaded dynamically based on mode -->
                        </div>
                    </div>
                    
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            üìö <span data-i18n="sidebar.library">Biblioth√®que</span>
                        </div>
                        <div id="templates-quick">
                            <button class="btn" style="width: 100%; margin-bottom: 10px;" onclick="loadTemplate('business-plan')">
                                üìä <span data-i18n="template.business">Business Plan</span>
                            </button>
                            <button class="btn" style="width: 100%; margin-bottom: 10px;" onclick="loadTemplate('study-notes')">
                                üéì <span data-i18n="template.study">Prise de Notes</span>
                            </button>
                            <button class="btn" style="width: 100%; margin-bottom: 10px;" onclick="loadTemplate('project-management')">
                                üíº <span data-i18n="template.project">Projet</span>
                            </button>
                            <button class="btn" style="width: 100%;" onclick="loadTemplate('brainstorming')">
                                üß™ <span data-i18n="template.brainstorm">Recherche</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            üí° <span data-i18n="sidebar.tips">Conseils</span>
                        </div>
                        <div id="tips-random" style="font-size: 14px; color: #6b7280;">
                            <!-- Random tips will be shown here -->
                        </div>
                    </div>
                </div>
                
                <!-- Maps Tab -->
                <div id="maps-tab" class="sidebar-pane" style="display: block;">
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            üìÇ <span data-i18n="sidebar.recent">Cartes R√©centes</span>
                        </div>
                        <div class="map-list" id="mapList">
                            <!-- Maps will be loaded here -->
                        </div>
                    </div>
                    
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            üìà <span data-i18n="sidebar.stats">Statistiques</span>
                        </div>
                        <div id="globalStats" style="font-size: 13px;">
                            <!-- Stats will be loaded here -->
                        </div>
                    </div>
                </div>
                
                <!-- Templates Tab -->
                <div id="templates-tab" class="sidebar-pane" style="display: none;">
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            ‚ú® <span data-i18n="sidebar.templates">Mod√®les Disponibles</span>
                        </div>
                        <div class="template-grid">
                            <div class="template-card" onclick="loadTemplate('business-plan')">
                                <div class="template-icon">üìä</div>
                                <div class="template-name" data-i18n="template.business">Plan d'Affaires</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('study-notes')">
                                <div class="template-icon">üéì</div>
                                <div class="template-name" data-i18n="template.study">Notes de Cours</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('project-management')">
                                <div class="template-icon">üíº</div>
                                <div class="template-name" data-i18n="template.project">Gestion Projet</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('brainstorming')">
                                <div class="template-icon">üß†</div>
                                <div class="template-name" data-i18n="template.brainstorm">Brainstorming</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('swot')">
                                <div class="template-icon">üéØ</div>
                                <div class="template-name" data-i18n="template.swot">Analyse SWOT</div>
                            </div>
                            <div class="template-card" onclick="loadTemplate('todo')">
                                <div class="template-icon">‚úÖ</div>
                                <div class="template-name" data-i18n="template.todo">Liste de T√¢ches</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Help Tab -->
                <div id="help-tab" class="sidebar-pane" style="display: none;">
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            üí° <span data-i18n="help.tips">Conseils Rapides</span>
                        </div>
                        <div style="font-size: 13px; line-height: 1.6;">
                            <p style="margin-bottom: 8px;" data-i18n="help.tip1">‚Ä¢ Double-cliquez pour cr√©er un n≈ìud</p>
                            <p style="margin-bottom: 8px;" data-i18n="help.tip2">‚Ä¢ Shift + Glisser pour naviguer</p>
                            <p style="margin-bottom: 8px;" data-i18n="help.tip3">‚Ä¢ Ctrl + S pour sauvegarder</p>
                            <p style="margin-bottom: 8px;" data-i18n="help.tip4">‚Ä¢ Delete pour supprimer</p>
                            <p style="margin-bottom: 8px;" data-i18n="help.tip5">‚Ä¢ Molette pour zoomer</p>
                        </div>
                    </div>
                    
                    <div class="sidebar-section">
                        <div class="sidebar-title">
                            ‚å®Ô∏è <span data-i18n="help.shortcuts">Raccourcis</span>
                        </div>
                        <table class="shortcuts-table" style="font-size: 12px;">
                            <tr>
                                <td>Ctrl+Z</td>
                                <td data-i18n="shortcut.undo">Annuler</td>
                            </tr>
                            <tr>
                                <td>Ctrl+Y</td>
                                <td data-i18n="shortcut.redo">Refaire</td>
                            </tr>
                            <tr>
                                <td>Ctrl+S</td>
                                <td data-i18n="shortcut.save">Sauvegarder</td>
                            </tr>
                            <tr>
                                <td>Delete</td>
                                <td data-i18n="shortcut.delete">Supprimer</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <button id="selectionDeleteBtn" title="Delete selected" style="display:none; position:absolute; z-index:50; padding:6px 8px; border-radius:4px; background:#ef4444; color:white; border:none; box-shadow:0 2px 6px rgba(0,0,0,0.2);">üóëÔ∏è</button>
            

            
            <!-- Arrow Properties Panel -->

            <!-- Score Modal -->
            <div id="scoreModal" class="modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 data-i18n="score.title">Analyse du Score</h3>
                        <span class="close" onclick="closeScoreModal()">&times;</span>
                    </div>
                    <div class="modal-body score-content">
                        <div class="score-metrics">
                            <div class="score-card">
                                <h4 data-i18n="score.overall">Score Global</h4>
                                <div class="score-value" id="overallScore">85</div>
                                <div class="score-description" data-i18n="score.excellent">Excellent</div>
                            </div>
                            
                            <div class="score-details">
                                <div class="score-item">
                                    <span data-i18n="score.structure">Structure :</span>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: 90%"></div>
                                    </div>
                                    <span class="score-number">90%</span>
                                </div>
                                
                                <div class="score-item">
                                    <span data-i18n="score.balance">√âquilibre :</span>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: 75%"></div>
                                    </div>
                                    <span class="score-number">75%</span>
                                </div>
                                
                                <div class="score-item">
                                    <span data-i18n="score.depth">Profondeur :</span>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: 80%"></div>
                                    </div>
                                    <span class="score-number">80%</span>
                                </div>
                                
                                <div class="score-item">
                                    <span data-i18n="score.connections">Connexions :</span>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: 85%"></div>
                                    </div>
                                    <span class="score-number">85%</span>
                                </div>
                            </div>
                            
                            <div class="score-analysis">
                                <h4 data-i18n="score.analysis">Analyse D√©taill√©e</h4>
                                <div class="analysis-text">
                                    <p><strong data-i18n="score.strengths">Points forts :</strong></p>
                                    <ul>
                                        <li data-i18n="score.strength1">Structure hi√©rarchique claire</li>
                                        <li data-i18n="score.strength2">Bonne r√©partition des n≈ìuds</li>
                                        <li data-i18n="score.strength3">Connexions logiques √©tablies</li>
                                    </ul>
                                    
                                    <p><strong data-i18n="score.improvements">Am√©liorations sugg√©r√©es :</strong></p>
                                    <ul>
                                        <li data-i18n="score.improve1">Ajouter plus de n≈ìuds secondaires</li>
                                        <li data-i18n="score.improve2">√âquilibrer les branches</li>
                                        <li data-i18n="score.improve3">Enrichir les √©tiquettes de connexions</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-primary" onclick="exportScoreReport()">
                            <span data-i18n="score.export">Exporter Rapport</span>
                        </button>
                        <button class="btn btn-secondary" onclick="closeScoreModal()">
                            <span data-i18n="btn.close">Fermer</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Stats Panel -->
            <div class="float-panel stats-panel">
                <div class="stat">
                    <div class="stat-value" id="nodeCount">0</div>
                    <div class="stat-label" data-i18n="stat.nodes">N≈ìuds</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="connectionCount">0</div>
                    <div class="stat-label" data-i18n="stat.links">Liens</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="currentMode">GRINDE</div>
                    <div class="stat-label" data-i18n="stat.mode">Mode</div>
                </div>
            </div>
            

        </div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel" id="rightPanel">
        <div class="sidebar-tabs">
            <button class="sidebar-tab active" onclick="showRightPanelTab('nodes')">
                <span data-i18n="rightpanel.nodes">Panneau N≈ìud</span>
            </button>
            <button class="sidebar-tab" onclick="showRightPanelTab('arrows')">
                <span data-i18n="rightpanel.arrows">Propri√©t√©s Fl√®che</span>
            </button>
        </div>
        
        <div class="sidebar-content">
            <!-- Nodes Tab -->
            <div id="nodes-tab" class="sidebar-pane" style="display: block;">
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        üîß <span data-i18n="rightpanel.node.properties">Propri√©t√©s du N≈ìud</span>
                        <span id="node-title-name" style="font-weight: normal; color: #666; margin-left: 8px;"></span>
                    </div>
                    <div id="node-properties-content">
                        <div id="node-form" style="display: none;">
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.text"><strong>Texte</strong></div>
                                <input type="text" class="property-input" id="nodeText" aria-label="Node text" title="Node text" placeholder="Titre du n≈ìud / Node text">
                            </div>
                            
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.text.size"><strong>Taille Texte</strong></div>
                                <div class="size-display-container">
                                    <span class="size-value-display" id="sizeValueDisplay">16</span>
                                    <input type="range" class="property-input" id="nodeSize" min="10" max="40" oninput="updateSizeDisplay()" aria-label="Node size" title="Node size">
                                </div>
                            </div>
                            
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.text.color"><strong>Couleur texte</strong></div>
                                <select class="property-input" id="nodeTextColor" onchange="updateTextColor()" aria-label="Text color" title="Text color">
                                    <option value="#000000" data-i18n="color.black">Noir</option>
                                    <option value="#ffffff" data-i18n="color.white">Blanc</option>
                                    <option value="#ff0000" data-i18n="color.red">Rouge</option>
                                    <option value="#0000ff" data-i18n="color.blue">Bleu</option>
                                    <option value="#008000" data-i18n="color.green">Vert</option>
                                </select>
                            </div>
                            
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.shape.size"><strong>Taille Forme</strong></div>
                                <div class="shape-size-container">
                                    <div class="shape-size-row">
                                        <label class="shape-size-label">X (largeur):</label>
                                        <span class="shape-size-value" id="shapeWidthDisplay">80</span>
                                        <input type="range" class="property-input shape-size-slider" id="shapeWidth" min="20" max="300" step="5" oninput="updateShapeSize()" aria-label="Shape width" title="Shape width">
                                    </div>
                                    <div class="shape-size-row">
                                        <label class="shape-size-label">Y (hauteur):</label>
                                        <span class="shape-size-value" id="shapeHeightDisplay">40</span>
                                        <input type="range" class="property-input shape-size-slider" id="shapeHeight" min="20" max="300" step="5" oninput="updateShapeSize()" aria-label="Shape height" title="Shape height">
                                    </div>
                                </div>
                            </div>
                            
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.shape"><strong>Forme</strong></div>
                                <select class="property-input" id="nodeShape" onchange="updateShapePreview()">
                                    <option value="rectangle" data-i18n="shape.rectangle">Rectangle</option>
                                    <option value="circle" data-i18n="shape.circle">Cercle</option>
                                    <option value="triangle-down" data-i18n="shape.triangle.down">Triangle pointe en bas</option>
                                    <option value="triangle-up" data-i18n="shape.triangle.up">Triangle pointe en haut</option>
                                    <option value="pentagon" data-i18n="shape.pentagon">Pentagone</option>
                                </select>
                            </div>
                            
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.color"><strong>Couleur</strong></div>
                                <div class="color-grid">
                                    <div class="color-option" style="background: #6366f1;" onclick="setNodeColor('#6366f1')"></div>
                                    <div class="color-option" style="background: #8b5cf6;" onclick="setNodeColor('#8b5cf6')"></div>
                                    <div class="color-option" style="background: #10b981;" onclick="setNodeColor('#10b981')"></div>
                                    <div class="color-option" style="background: #f59e0b;" onclick="setNodeColor('#f59e0b')"></div>
                                    <div class="color-option" style="background: #ef4444;" onclick="setNodeColor('#ef4444')"></div>
                                    <div class="color-option" style="background: #06b6d4;" onclick="setNodeColor('#06b6d4')"></div>
                                    <div class="color-option" style="background: #ec4899;" onclick="setNodeColor('#ec4899')"></div>
                                    <div class="color-option" style="background: #84cc16;" onclick="setNodeColor('#84cc16')"></div>
                                    <div class="color-option" style="background: #64748b;" onclick="setNodeColor('#64748b')"></div>
                                    <div class="color-option" style="background: #0ea5e9;" onclick="setNodeColor('#0ea5e9')"></div>
                                    <div class="color-option" style="background: #a855f7;" onclick="setNodeColor('#a855f7')"></div>
                                    <div class="color-option" style="background: #f97316;" onclick="setNodeColor('#f97316')"></div>
                                </div>
                            </div>
                            
                            <div class="property-buttons">
                                <button class="btn btn-primary" onclick="saveNodeProperties()">
                                    <span data-i18n="btn.save">Enregistrer</span>
                                </button>
                                <button class="btn btn-secondary" onclick="cancelNodeProperties()">
                                    <span data-i18n="btn.cancel">Annuler</span>
                                </button>
                            </div>
                            
                            <div class="shape-preview" id="shapePreview">
                                <div class="shape-preview-label" data-i18n="preview.shape">Aper√ßu forme :</div>
                                <canvas id="previewCanvas" width="100" height="60"></canvas>
                            </div>
                        </div>
                        <p id="no-node-message" class="no-selection-message" data-i18n="rightpanel.no.selection">S√©lectionnez un n≈ìud pour voir ses propri√©t√©s</p>
                    </div>
                </div>
            </div>
            
            <!-- Arrows Tab -->
            <div id="arrows-tab" class="sidebar-pane" style="display: none;">
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        ‚û°Ô∏è <span data-i18n="rightpanel.arrow.properties">Propri√©t√©s de la Fl√®che</span>
                    </div>
                    <div id="arrow-properties-content">
                        <div id="arrow-form" style="display: none;">
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.arrow.id">ID</div>
                                <input type="text" class="property-input" id="arrowId" readonly aria-label="Connection id" title="Connection id">
                            </div>
                            
                            <div class="property-group">
                                <div class="property-label" data-i18n="property.arrow.text">Texte</div>
                                <input type="text" class="property-input" id="arrowText" placeholder="√âtiquette de la fl√®che" aria-label="Connection label" title="Connection label">
                            </div>
                            
                            <div class="property-buttons">
                                <button class="btn btn-primary" onclick="saveArrowProperties()">
                                    <span data-i18n="btn.save">Enregistrer</span>
                                </button>
                                <button class="btn btn-secondary" onclick="cancelArrowProperties()">
                                    <span data-i18n="btn.cancel">Annuler</span>
                                </button>
                            </div>
                        </div>
                        <p id="no-arrow-message" class="no-selection-message" data-i18n="rightpanel.no.arrow.selection">S√©lectionnez une fl√®che pour voir ses propri√©t√©s</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Guide Modal -->
    <div class="modal" id="guideModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">
                    üìñ <span data-i18n="guide.title">Guide Mind Map Mini</span>
                </h2>
                <button class="close-btn" onclick="closeModal('guideModal')">&times;</button>
            </div>
            
            <div class="guide-section">
                <h3 data-i18n="guide.quickstart">üéØ D√©marrage Rapide</h3>
                <p data-i18n="guide.intro">Mind Map Mini est un outil l√©ger de cartographie mentale qui sauvegarde tout en fichiers JSON. Pas de base de donn√©es, pas de complexit√© - juste du mind mapping pur !</p>
            </div>
            
            <div class="guide-section">
                <h3 data-i18n="guide.grinde.title">üß† M√©thode GRINDE (Recommand√©e)</h3>
                
                <div class="guide-card grinde">
                    <h4>G - <span data-i18n="guide.grinde.grouped">Regroup√©</span></h4>
                    <p data-i18n="guide.grinde.grouped.desc">Organisez l'information en chunks logiques. Cr√©ez des groupes visuels pour les concepts li√©s.</p>
                </div>
                
                <div class="guide-card grinde">
                    <h4>R - <span data-i18n="guide.grinde.reflective">R√©flexif</span></h4>
                    <p data-i18n="guide.grinde.reflective.desc">Ne copiez pas - transformez l'information avec vos propres mots.</p>
                </div>
                
                <div class="guide-card grinde">
                    <h4>I - <span data-i18n="guide.grinde.interconnected">Interconnect√©</span></h4>
                    <p data-i18n="guide.grinde.interconnected.desc">Cr√©ez de multiples connexions entre les concepts pour renforcer la compr√©hension.</p>
                </div>
                
                <div class="guide-card grinde">
                    <h4>N - <span data-i18n="guide.grinde.nonverbal">Non-verbal</span></h4>
                    <p data-i18n="guide.grinde.nonverbal.desc">Utilisez images, symboles et couleurs pour am√©liorer la m√©morisation.</p>
                </div>
                
                <div class="guide-card grinde">
                    <h4>D - <span data-i18n="guide.grinde.directional">Directionnel</span></h4>
                    <p data-i18n="guide.grinde.directional.desc">Montrez le flux logique et la causalit√© avec des fl√®ches directionnelles.</p>
                </div>
                
                <div class="guide-card grinde">
                    <h4>E - <span data-i18n="guide.grinde.emphasized">Accentu√©</span></h4>
                    <p data-i18n="guide.grinde.emphasized.desc">Utilisez taille, couleur et style pour mettre en √©vidence les √©l√©ments importants.</p>
                </div>
            </div>
            
            <div class="guide-section">
                <h3 data-i18n="guide.buzan.title">üåü M√©thode Buzan (Classique)</h3>
                <div class="guide-card buzan">
                    <p data-i18n="guide.buzan.desc">Structure radiante traditionnelle avec un centre et des branches qui rayonnent vers l'ext√©rieur. Id√©al pour la cr√©ativit√© et les pr√©sentations.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Map Modal -->
    <div id="loadMapModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-i18n="load.title">Ouvrir une Mind Map</h2>
                <span class="close-button" onclick="closeModal('loadMapModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div id="mapsList">
                    <p data-i18n="load.loading">Chargement des cartes...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Internationalization
        const i18n = {
            fr: {
                'app.title': 'Mind Map Mini',
                'autosave.label': 'AutoSave',
                'mode.grinde': 'GRINDE',
                'mode.buzan': 'Buzan',
                'btn.guide': 'Guide',
                'btn.save': 'Sauvegarder',
                'btn.cancel': 'Annuler',
                'btn.new': 'Nouveau',
                'btn.open': 'Ouvrir',
                'btn.duplicate': 'Dupliquer',
                'btn.close': 'Fermer',
                'btn.connect': 'Connecter',
                'btn.delete': 'Supprimer',
                'btn.reset': 'R√©initialiser',
                'btn.sidebar': 'Panneau gauche',
                'btn.rightpanel': 'Panneau droit',
                'btn.tools': 'Panneau OUTILS',
                'toolbar.file': 'Fichier',
                'toolbar.tools': 'Outils',
                'toolbar.nodes': 'N≈ìuds',
                'toolbar.edit': '√âdition',
                'toolbar.export': 'Export',
                'toolbar.guide': 'Guide',
                'toolbar.view': 'Affichage',
                'node.central': 'Central',
                'node.group': 'Groupe',
                'node.concept': 'Concept',
                'node.detail': 'D√©tail',
                'sidebar.maps': 'Mes Cartes',
                'sidebar.templates': 'Mod√®les',
                'sidebar.help': 'Aide',
                'rightpanel.nodes': 'Propri√©t√©s N≈ìuds',
                'rightpanel.arrows': 'Propri√©t√©s Lien',
                'rightpanel.node.properties': 'Propri√©t√©s du N≈ìud',
                'rightpanel.arrow.properties': 'Propri√©t√©s de la Fl√®che',
                'rightpanel.no.selection': 'S√©lectionnez un n≈ìud pour voir ses propri√©t√©s',
                'rightpanel.no.arrow.selection': 'S√©lectionnez une fl√®che pour voir ses propri√©t√©s',
                'sidebar.principles': 'Principes Actifs',
                'sidebar.library': 'Biblioth√®que',
                'sidebar.tips': 'Conseils',
                'sidebar.recent': 'Cartes R√©centes',
                'sidebar.stats': 'Statistiques',
                'template.business': 'Plan d\'Affaires',
                'template.study': 'Notes de Cours',
                'template.project': 'Gestion Projet',
                'template.brainstorm': 'Brainstorming',
                'template.swot': 'Analyse SWOT',
                'template.todo': 'Liste de T√¢ches',
                'panel.properties': 'Propri√©t√©s',
                'panel.node.properties': 'Propri√©t√©s n≈ìud',
                'panel.arrow.properties': 'Propri√©t√©s Fl√®che',
                'panel.close': 'Fermer',
                'property.text': 'Texte',
                'property.size': 'Taille',
                'property.text.size': 'Taille Texte',
                'property.text.color': 'Couleur texte',
                'property.shape.size': 'Taille Forme',
                'property.shape': 'Forme',
                'property.arrow.id': 'ID',
                'property.arrow.text': 'Texte',
                'property.color': 'Couleur',
                'color.black': 'Noir',
                'color.white': 'Blanc',
                'color.red': 'Rouge',
                'color.blue': 'Bleu',
                'color.green': 'Vert',
                'shape.rectangle': 'Rectangle',
                'shape.circle': 'Cercle',
                'shape.triangle.down': 'Triangle pointe en bas',
                'shape.triangle.up': 'Triangle pointe en haut',
                'shape.pentagon': 'Pentagone',
                'stat.nodes': 'N≈ìuds',
                'stat.links': 'Liens',
                'stat.mode': 'Mode',
                'quick.concept': 'Concept',
                'quick.group': 'Groupe',
                'quick.detail': 'D√©tail',
                'help.tips': 'Conseils Rapides',
                'help.tip1': '‚Ä¢ Double-cliquez pour cr√©er un n≈ìud',
                'help.tip2': '‚Ä¢ Shift + Glisser pour naviguer',
                'help.tip3': '‚Ä¢ Ctrl + S pour sauvegarder',
                'help.tip4': '‚Ä¢ Delete pour supprimer',
                'guide.quick': 'Guide Rapide',
                'guide.templates': 'Mod√®les',
                'guide.shortcuts': 'Raccourcis',
                'help.tip5': '‚Ä¢ Molette pour zoomer',
                'help.shortcuts': 'Raccourcis',
                'shortcut.undo': 'Annuler',
                'shortcut.redo': 'Refaire',
                'shortcut.save': 'Sauvegarder',
                'shortcut.delete': 'Supprimer',
                'guide.title': 'Guide Mind Map Mini',
                'guide.quickstart': 'üéØ D√©marrage Rapide',
                'guide.intro': 'Mind Map Mini est un outil l√©ger de cartographie mentale qui sauvegarde tout en fichiers JSON. Pas de base de donn√©es, pas de complexit√© - juste du mind mapping pur !',
                'guide.grinde.title': 'üß† M√©thode GRINDE (Recommand√©e)',
                'guide.grinde.grouped': 'Regroup√©',
                'guide.grinde.grouped.desc': 'Organisez l\'information en chunks logiques. Cr√©ez des groupes visuels pour les concepts li√©s.',
                'guide.grinde.reflective': 'R√©flexif',
                'guide.grinde.reflective.desc': 'Ne copiez pas - transformez l\'information avec vos propres mots.',
                'guide.grinde.interconnected': 'Interconnect√©',
                'guide.grinde.interconnected.desc': 'Cr√©ez de multiples connexions entre les concepts pour renforcer la compr√©hension.',
                'guide.grinde.nonverbal': 'Non-verbal',
                'guide.grinde.nonverbal.desc': 'Utilisez images, symboles et couleurs pour am√©liorer la m√©morisation.',
                'guide.grinde.directional': 'Directionnel',
                'guide.grinde.directional.desc': 'Montrez le flux logique et la causalit√© avec des fl√®ches directionnelles.',
                'guide.grinde.emphasized': 'Accentu√©',
                'guide.grinde.emphasized.desc': 'Utilisez taille, couleur et style pour mettre en √©vidence les √©l√©ments importants.',
                'guide.buzan.title': 'üåü M√©thode Buzan (Classique)',
                'guide.buzan.desc': 'Structure radiante traditionnelle avec un centre et des branches qui rayonnent vers l\'ext√©rieur. Id√©al pour la cr√©ativit√© et les pr√©sentations.',
                'prompt.node.text': 'Entrez le texte du n≈ìud :',
                'prompt.node.central': 'Entrez l\'id√©e centrale :',
                'prompt.node.group': 'Entrez le nom du groupe :',
                'prompt.node.concept': 'Entrez le concept :',
                'prompt.node.detail': 'Entrez le d√©tail :',
                'prompt.map.title': 'Titre de la carte :',
                'prompt.rename.title': 'Nouveau titre :',
                'toast.saved': 'Carte sauvegard√©e !',
                'toast.loaded': 'Carte charg√©e !',
                'toast.closed': 'Carte ferm√©e',
                'toast.renamed': 'Carte renomm√©e !',
                'toast.deleted': 'Carte supprim√©e !',
                'toast.error': 'Erreur',
                'principles.g': 'Regroupez les concepts',
                'principles.r': 'R√©fl√©chissez avant d\'ajouter',
                'principles.i': 'Interconnectez tout',
                'principles.n': 'Utilisez des visuels',
                'principles.d': 'Montrez la direction',
                'principles.e': 'Accentuez l\'important',
                'buzan.radiant': 'Structure radiante',
                'buzan.keyword': 'Un mot-cl√© par branche',
                'buzan.colors': 'Couleurs vibrantes',
                'buzan.images': 'Images et symboles',
                'buzan.curves': 'Branches courbes',
                'buzan.hierarchy': 'Hi√©rarchie claire',
                'tip.doubleclick': 'üí° Double-cliquez pour cr√©er un nouveau n≈ìud',
                'tip.shift': 'üí° Maintenez Shift et glissez pour naviguer',
                'tip.wheel': 'üí° Utilisez la molette pour zoomer',
                'tip.delete': 'üí° Supprimez avec la touche Delete',
                'tip.save': 'üí° Ctrl+S pour sauvegarder rapidement',
                'tip.curves': 'üí° Les connexions courbes aident la m√©morisation',
                'tip.words': 'üí° Limitez-vous √† 3 mots par n≈ìud',
                'tip.colors': 'üí° Les couleurs am√©liorent la r√©tention de 80%',
                'confirm.new': 'Cr√©er une nouvelle carte ? Les modifications non sauvegard√©es seront perdues.',
                'confirm.close': 'Fermer cette carte ? Les modifications non sauvegard√©es seront perdues.',
                'confirm.save_before_close': 'Voulez-vous sauvegarder avant de fermer ?',
                'confirm.delete.map': 'Supprimer d√©finitivement la carte "{title}" ? Cette action est irr√©versible.',
                'load.title': 'Ouvrir une Mind Map',
                'load.loading': 'Chargement des cartes...',
                'load.no_maps': 'Aucune carte sauvegard√©e trouv√©e.',
                'load.select': 'S√©lectionnez une carte √† ouvrir :',
                'load.confirm': 'Ouvrir cette carte ? Les modifications non sauvegard√©es seront perdues.',
                'confirm.delete': 'Supprimer ce n≈ìud ?',
                'score.title': 'Analyse du Score',
                'score.overall': 'Score Global',
                'score.structure': 'Structure',
                'score.balance': '√âquilibre',
                'score.depth': 'Profondeur',
                'score.connections': 'Connexions',
                'score.analysis': 'Analyse D√©taill√©e',
                'score.strengths': 'Points forts',
                'score.improvements': 'Am√©liorations sugg√©r√©es',
                'score.strength1': 'Structure hi√©rarchique claire',
                'score.strength2': 'Bonne r√©partition des n≈ìuds',
                'score.strength3': 'Connexions logiques √©tablies',
                'score.improve1': 'Ajouter plus de n≈ìuds secondaires',
                'score.improve2': '√âquilibrer les branches',
                'score.improve3': 'Enrichir les √©tiquettes de connexions',
                'score.export': 'Exporter Rapport',
                'score.excellent': 'Excellent',
                'score.very_good': 'Tr√®s Bon',
                'score.good': 'Bon',
                'score.fair': 'Correct',
                'score.needs_improvement': '√Ä Am√©liorer',
                'toast.exported': 'Rapport export√© !'
            },
            en: {
                'app.title': 'Mind Map Mini',
                'autosave.label': 'AutoSave',
                'mode.grinde': 'GRINDE',
                'mode.buzan': 'Buzan',
                'btn.guide': 'Guide',
                'btn.save': 'Save',
                'btn.cancel': 'Cancel',
                'btn.new': 'New',
                'btn.open': 'Open',
                'btn.duplicate': 'Duplicate',
                'btn.close': 'Close',
                'btn.connect': 'Connect',
                'btn.delete': 'Delete',
                'btn.reset': 'Reset',
                'btn.sidebar': 'Left Panel',
                'btn.rightpanel': 'Right Panel',
                'btn.tools': 'TOOLS Panel',
                'toolbar.file': 'File',
                'toolbar.tools': 'Tools',
                'toolbar.nodes': 'Nodes',
                'toolbar.edit': 'Edit',
                'toolbar.export': 'Export',
                'toolbar.guide': 'Guide',
                'toolbar.view': 'View',
                'node.central': 'Central',
                'node.group': 'Group',
                'node.concept': 'Concept',
                'node.detail': 'Detail',
                'sidebar.maps': 'My Maps',
                'sidebar.templates': 'Templates',
                'sidebar.help': 'Help',
                'rightpanel.nodes': 'Node Properties',
                'rightpanel.arrows': 'Link Properties',
                'rightpanel.node.properties': 'Node Properties',
                'rightpanel.arrow.properties': 'Arrow Properties',
                'rightpanel.no.selection': 'Select a node to view its properties',
                'rightpanel.no.arrow.selection': 'Select an arrow to view its properties',
                'sidebar.principles': 'Active Principles',
                'sidebar.library': 'Library',
                'sidebar.tips': 'Tips',
                'sidebar.recent': 'Recent Maps',
                'sidebar.stats': 'Statistics',
                'template.business': 'Business Plan',
                'template.study': 'Study Notes',
                'template.project': 'Project Management',
                'template.brainstorm': 'Brainstorming',
                'template.swot': 'SWOT Analysis',
                'template.todo': 'Task List',
                'panel.properties': 'Properties',
                'panel.node.properties': 'Node Properties',
                'panel.arrow.properties': 'Arrow Properties',
                'panel.close': 'Close',
                'property.text': 'Text',
                'property.size': 'Size',
                'property.text.size': 'Text Size',
                'property.text.color': 'Text Color',
                'property.shape.size': 'Shape Size',
                'property.shape': 'Shape',
                'property.arrow.id': 'ID',
                'property.arrow.text': 'Text',
                'property.color': 'Color',
                'color.black': 'Black',
                'color.white': 'White',
                'color.red': 'Red',
                'color.blue': 'Blue',
                'color.green': 'Green',
                'shape.rectangle': 'Rectangle',
                'shape.circle': 'Circle',
                'shape.triangle.down': 'Triangle down',
                'shape.triangle.up': 'Triangle up',
                'shape.pentagon': 'Pentagon',
                'stat.nodes': 'Nodes',
                'stat.links': 'Links',
                'stat.mode': 'Mode',
                'quick.concept': 'Concept',
                'quick.group': 'Group',
                'quick.detail': 'Detail',
                'help.tips': 'Quick Tips',
                'help.tip1': '‚Ä¢ Double-click to create a node',
                'help.tip2': '‚Ä¢ Shift + Drag to navigate',
                'help.tip3': '‚Ä¢ Ctrl + S to save',
                'help.tip4': '‚Ä¢ Delete to remove',
                'guide.quick': 'Quick Guide',
                'guide.templates': 'Templates',
                'guide.shortcuts': 'Shortcuts',
                'help.tip5': '‚Ä¢ Scroll wheel to zoom',
                'help.shortcuts': 'Shortcuts',
                'shortcut.undo': 'Undo',
                'shortcut.redo': 'Redo',
                'shortcut.save': 'Save',
                'shortcut.delete': 'Delete',
                'guide.title': 'Mind Map Mini Guide',
                'guide.quickstart': 'üéØ Quick Start',
                'guide.intro': 'Mind Map Mini is a lightweight mind mapping tool that saves everything as JSON files. No database, no complexity - just pure mind mapping!',
                'guide.grinde.title': 'üß† GRINDE Method (Recommended)',
                'guide.grinde.grouped': 'Grouped',
                'guide.grinde.grouped.desc': 'Organize information in logical chunks. Create visual groups for related concepts.',
                'guide.grinde.reflective': 'Reflective',
                'guide.grinde.reflective.desc': 'Don\'t copy - transform information using your own words.',
                'guide.grinde.interconnected': 'Interconnected',
                'guide.grinde.interconnected.desc': 'Create multiple connections between concepts to strengthen understanding.',
                'guide.grinde.nonverbal': 'Non-verbal',
                'guide.grinde.nonverbal.desc': 'Use images, symbols, and colors to enhance memory retention.',
                'guide.grinde.directional': 'Directional',
                'guide.grinde.directional.desc': 'Show logical flow and causality with directional arrows.',
                'guide.grinde.emphasized': 'Emphasized',
                'guide.grinde.emphasized.desc': 'Use size, color, and style to highlight important elements.',
                'guide.buzan.title': 'üåü Buzan Method (Classic)',
                'guide.buzan.desc': 'Traditional radiant structure with a center and branches radiating outward. Ideal for creativity and presentations.',
                'prompt.node.text': 'Enter node text:',
                'prompt.node.central': 'Enter central idea:',
                'prompt.node.group': 'Enter group name:',
                'prompt.node.concept': 'Enter concept:',
                'prompt.node.detail': 'Enter detail:',
                'prompt.map.title': 'Map title:',
                'prompt.rename.title': 'New title:',
                'toast.saved': 'Map saved!',
                'toast.loaded': 'Map loaded!',
                'toast.closed': 'Map closed',
                'toast.renamed': 'Map renamed!',
                'toast.deleted': 'Map deleted!',
                'toast.error': 'Error',
                'principles.g': 'Group concepts',
                'principles.r': 'Reflect before adding',
                'principles.i': 'Interconnect everything',
                'principles.n': 'Use visuals',
                'principles.d': 'Show direction',
                'principles.e': 'Emphasize important',
                'buzan.radiant': 'Radiant structure',
                'buzan.keyword': 'One keyword per branch',
                'buzan.colors': 'Vibrant colors',
                'buzan.images': 'Images and symbols',
                'buzan.curves': 'Curved branches',
                'buzan.hierarchy': 'Clear hierarchy',
                'tip.doubleclick': 'üí° Double-click to create a new node',
                'tip.shift': 'üí° Hold Shift and drag to navigate',
                'tip.wheel': 'üí° Use mouse wheel to zoom',
                'tip.delete': 'üí° Press Delete to remove',
                'tip.save': 'üí° Ctrl+S to save quickly',
                'tip.curves': 'üí° Curved connections help memory',
                'tip.words': 'üí° Limit to 3 words per node',
                'tip.colors': 'üí° Colors improve retention by 80%',
                'confirm.new': 'Create new map? Unsaved changes will be lost.',
                'confirm.close': 'Close this map? Unsaved changes will be lost.',
                'confirm.save_before_close': 'Do you want to save before closing?',
                'confirm.delete.map': 'Permanently delete map "{title}"? This action cannot be undone.',
                'load.title': 'Open a Mind Map',
                'load.loading': 'Loading maps...',
                'load.no_maps': 'No saved maps found.',
                'load.select': 'Select a map to open:',
                'load.confirm': 'Open this map? Unsaved changes will be lost.',
                'confirm.delete': 'Delete this node?',
                'score.title': 'Score Analysis',
                'score.overall': 'Overall Score',
                'score.structure': 'Structure',
                'score.balance': 'Balance',
                'score.depth': 'Depth',
                'score.connections': 'Connections',
                'score.analysis': 'Detailed Analysis',
                'score.strengths': 'Strengths',
                'score.improvements': 'Suggested Improvements',
                'score.strength1': 'Clear hierarchical structure',
                'score.strength2': 'Good node distribution',
                'score.strength3': 'Logical connections established',
                'score.improve1': 'Add more secondary nodes',
                'score.improve2': 'Balance the branches',
                'score.improve3': 'Enrich connection labels',
                'score.export': 'Export Report',
                'score.excellent': 'Excellent',
                'score.very_good': 'Very Good',
                'score.good': 'Good',
                'score.fair': 'Fair',
                'score.needs_improvement': 'Needs Improvement',
                'toast.exported': 'Report exported!'
            }
        };

        // Global State
        let currentLanguage = 'fr';
        let currentMap = {
            id: null,
            title: 'Nouvelle Carte Mentale',
            mode: 'grinde',
            nodes: [],
            connections: [],
            stylo_drawings: []
        };
        
        let selectedNode = null;
        let selectedConnection = null;
        let currentTool = 'select';
        let isDragging = false;
        let isConnecting = false;
        let connectStart = null;
        let dragOffset = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };
        
        // Pen/Stylo drawing variables
        let isDrawing = false;
        let drawStart = null;
        let selectedPenSize = 2;
        let selectedPenColor = '#ff69b4';
        let mouseX = 0;
        let mouseY = 0;
        let zoom = 1;
        let canvas, ctx;
        let history = [];
        let historyIndex = -1;
        
        // AutoSave configuration
        let autoSaveEnabled = true;
        let autoSaveFrequency = 60; // seconds
        let autoSaveTimer = null;
        let autosaveTimer = null;
        
        // Area selection variables
        let isAreaSelecting = false;
        let areaSelectStart = { x: 0, y: 0 };
        let areaSelectEnd = { x: 0, y: 0 };
        let selectedNodes = [];
        let selectedConnections = [];
        let selectedStyloDrawings = [];
        let isDraggingSelection = false;
        let selectionOffset = { x: 0, y: 0 };
        
        // Sidebar state
        let sidebarVisible = true;
        let toolsVisible = true;
        let rightPanelVisible = true;
        
        // Set Language
        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            
            // Update buttons
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.lang-btn.${lang}`).classList.add('active');
            
            // Update all texts
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (i18n[lang][key]) {
                    element.textContent = i18n[lang][key];
                }
            });
            
            // Save preference
            localStorage.setItem('language', lang);
        }
        
        function t(key) {
            return i18n[currentLanguage][key] || key;
        }
        
        // Node Class
        class Node {
            constructor(x, y, text, type = 'concept') {
                this.id = 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.text = text;
                this.type = type;
                this.size = this.getDefaultSize();
                this.color = this.getDefaultColor();
                this.shape = this.getDefaultShape();
                this.shapeWidth = this.getDefaultShapeWidth();
                this.shapeHeight = this.getDefaultShapeHeight();
            }
            
            getDefaultSize() {
                const sizes = {
                    'central': 30,
                    'group': 25,
                    'concept': 20,
                    'detail': 15
                };
                return sizes[this.type] || 20;
            }
            
            getDefaultColor() {
                const colors = {
                    'central': '#6366f1',
                    'group': '#f59e0b',
                    'concept': '#10b981',
                    'detail': '#9ca3af'
                };
                return colors[this.type] || '#6366f1';
            }
            
            getDefaultShape() {
                // Central nodes default to circle, others to rectangle
                return this.type === 'central' ? 'circle' : 'rectangle';
            }
            
            getDefaultShapeWidth() {
                const calculated = Math.max(this.text.length * 7 + 20, 80);
                console.log('Default width for node:', this.text, '=', calculated);
                return calculated;
            }
            
            getDefaultShapeHeight() {
                const calculated = Math.max(this.size * 2, 30);
                console.log('Default height for node:', this.text, '=', calculated);
                return calculated;
            }
            
            draw(ctx) {
                ctx.save();
                
                // Shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw node
                ctx.fillStyle = this.color;
                ctx.strokeStyle = selectedNode === this ? '#1f2937' : '#ffffff';
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                
                const width = this.shapeWidth || this.getDefaultShapeWidth();
                const height = this.shapeHeight || this.getDefaultShapeHeight();
                
                // Debug: log shape dimensions when selected
                if (selectedNode === this && this.shapeWidth) {
                    console.log('Drawing node with custom size:', width, height, 'from properties:', this.shapeWidth, this.shapeHeight);
                }
                
                if (this.shape === 'circle') {
                    // Circle shape - use width and height to determine radius
                    const radius = Math.max(width, height) / 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (this.shape === 'triangle-down') {
                    // Triangle pointing down
                    const baseWidth = width * 0.8;
                    const triangleHeight = height * 1.2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + triangleHeight/2); // Bottom point
                    ctx.lineTo(this.x - baseWidth/2, this.y - triangleHeight/2); // Top left
                    ctx.lineTo(this.x + baseWidth/2, this.y - triangleHeight/2); // Top right
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.shape === 'triangle-up') {
                    // Triangle pointing up
                    const baseWidth = width * 0.8;
                    const triangleHeight = height * 1.2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - triangleHeight/2); // Top point
                    ctx.lineTo(this.x - baseWidth/2, this.y + triangleHeight/2); // Bottom left
                    ctx.lineTo(this.x + baseWidth/2, this.y + triangleHeight/2); // Bottom right
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.shape === 'pentagon') {
                    // Pentagon shape
                    const radius = Math.max(width, height) / 2;
                    const sides = 5;
                    ctx.beginPath();
                    for (let i = 0; i <= sides; i++) {
                        const angle = (i * 2 * Math.PI) / sides - Math.PI / 2; // Start from top
                        const x = this.x + radius * Math.cos(angle);
                        const y = this.y + radius * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Rectangle shape (rounded rectangle) - default
                    const radius = 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x - width/2 + radius, this.y - height/2);
                    ctx.lineTo(this.x + width/2 - radius, this.y - height/2);
                    ctx.quadraticCurveTo(this.x + width/2, this.y - height/2, this.x + width/2, this.y - height/2 + radius);
                    ctx.lineTo(this.x + width/2, this.y + height/2 - radius);
                    ctx.quadraticCurveTo(this.x + width/2, this.y + height/2, this.x + width/2 - radius, this.y + height/2);
                    ctx.lineTo(this.x - width/2 + radius, this.y + height/2);
                    ctx.quadraticCurveTo(this.x - width/2, this.y + height/2, this.x - width/2, this.y + height/2 - radius);
                    ctx.lineTo(this.x - width/2, this.y - height/2 + radius);
                    ctx.quadraticCurveTo(this.x - width/2, this.y - height/2, this.x - width/2 + radius, this.y - height/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                
                // Text
                ctx.fillStyle = this.textColor || (this.type === 'detail' ? '#1f2937' : '#ffffff');
                ctx.font = `${this.size * 0.7}px -apple-system, BlinkMacSystemFont, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
                
                ctx.restore();
            }
            
            isPointInside(x, y) {
                const width = Math.max(this.text.length * 7 + 20, 80);
                const height = this.size * 2;
                
                if (this.shape === 'circle') {
                    // Circle detection
                    const radius = this.type === 'central' ? this.size + 10 : Math.max(width, height) / 2;
                    const dx = x - this.x;
                    const dy = y - this.y;
                    return Math.sqrt(dx * dx + dy * dy) <= radius;
                } else if (this.shape === 'triangle-down') {
                    // Triangle down detection (simplified to rectangular area)
                    const baseWidth = width * 0.8;
                    const triangleHeight = height * 1.2;
                    return x >= this.x - baseWidth/2 && x <= this.x + baseWidth/2 &&
                           y >= this.y - triangleHeight/2 && y <= this.y + triangleHeight/2;
                } else if (this.shape === 'triangle-up') {
                    // Triangle up detection (simplified to rectangular area)
                    const baseWidth = width * 0.8;
                    const triangleHeight = height * 1.2;
                    return x >= this.x - baseWidth/2 && x <= this.x + baseWidth/2 &&
                           y >= this.y - triangleHeight/2 && y <= this.y + triangleHeight/2;
                } else if (this.shape === 'pentagon') {
                    // Pentagon detection (simplified to circular area)
                    const radius = Math.max(width, height) / 2;
                    const dx = x - this.x;
                    const dy = y - this.y;
                    return Math.sqrt(dx * dx + dy * dy) <= radius;
                } else {
                    // Rectangle detection (default)
                    return x >= this.x - width/2 && x <= this.x + width/2 &&
                           y >= this.y - height/2 && y <= this.y + height/2;
                }
            }
        }
        
        // Connection Class
        class Connection {
            constructor(source, target, type = 'simple') {
                this.id = 'conn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.source = source;
                this.target = target;
                this.type = type;
                this.color = '#6366f1';
                this.text = ''; // Add text property for arrow labels
            }
            
            draw(ctx) {
                ctx.save();
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                
                if (currentMap.mode === 'grinde') {
                    // Curved connection for GRINDE
                    ctx.beginPath();
                    ctx.moveTo(this.source.x, this.source.y);
                    const cp1x = (this.source.x + this.target.x) / 2;
                    const cp1y = this.source.y;
                    const cp2x = (this.source.x + this.target.x) / 2;
                    const cp2y = this.target.y;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, this.target.x, this.target.y);
                    ctx.stroke();
                } else {
                    // Straight connection for Buzan
                    ctx.beginPath();
                    ctx.moveTo(this.source.x, this.source.y);
                    ctx.lineTo(this.target.x, this.target.y);
                    ctx.stroke();
                }
                
                // Draw arrow if needed
                if (this.type === 'arrow') {
                    const angle = Math.atan2(this.target.y - this.source.y, this.target.x - this.source.x);
                    const arrowLength = 12;
                    const arrowAngle = Math.PI / 6;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.target.x, this.target.y);
                    ctx.lineTo(
                        this.target.x - arrowLength * Math.cos(angle - arrowAngle),
                        this.target.y - arrowLength * Math.sin(angle - arrowAngle)
                    );
                    ctx.moveTo(this.target.x, this.target.y);
                    ctx.lineTo(
                        this.target.x - arrowLength * Math.cos(angle + arrowAngle),
                        this.target.y - arrowLength * Math.sin(angle + arrowAngle)
                    );
                    ctx.stroke();
                }
                
                // Draw text label if exists
                if (this.text && this.text.trim()) {
                    const midX = (this.source.x + this.target.x) / 2;
                    const midY = (this.source.y + this.target.y) / 2;
                    
                    // Calculate text background rectangle
                    ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
                    const textMetrics = ctx.measureText(this.text);
                    const textWidth = textMetrics.width;
                    const textHeight = 16;
                    const padding = 4;
                    
                    // Draw background rectangle
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1;
                    ctx.fillRect(
                        midX - textWidth/2 - padding,
                        midY - textHeight/2 - padding,
                        textWidth + padding * 2,
                        textHeight + padding * 2
                    );
                    ctx.strokeRect(
                        midX - textWidth/2 - padding,
                        midY - textHeight/2 - padding,
                        textWidth + padding * 2,
                        textHeight + padding * 2
                    );
                    
                    // Draw text
                    ctx.fillStyle = '#1f2937';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.text, midX, midY);
                }
                
                ctx.restore();
            }
            
            // Check if a point is near this connection
            isNearPoint(x, y, threshold = 8) {
                // Calculate distance from point to line segment
                const dx = this.target.x - this.source.x;
                const dy = this.target.y - this.source.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return false;
                
                const t = Math.max(0, Math.min(1, ((x - this.source.x) * dx + (y - this.source.y) * dy) / (length * length)));
                const projX = this.source.x + t * dx;
                const projY = this.source.y + t * dy;
                
                const distance = Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY));
                return distance <= threshold;
            }
        }
        
        // Initialize
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Load language preference
            const savedLang = localStorage.getItem('language') || 'fr';
            setLanguage(savedLang);
            
            // Initialize sidebar toggle state
            initSidebarToggle();
            
            // Initialize tools toggle state
            initToolsToggle();
            
            // Initialize right panel toggle state
            initRightPanelToggle();
            
            // Load AutoSave settings
            loadAutoSaveSettings();
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Event listeners
            canvas.addEventListener('dblclick', handleDoubleClick);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // Keyboard
            document.addEventListener('keydown', handleKeyDown);
            
            // Load saved maps list
            loadMapsList();
            
            // Initialize menus
            initMenus();
            
            // Initialize maps tab (instead of principles)
            showSidebarTab('maps');
            showRandomTip();
            
            // Load most recent map or start with new map
            loadMostRecentMapOrNew();
            // Save initial state for undo/redo
            history = [];
            historyIndex = -1;
            saveHistory();
            
            // Start render loop
            render();
        }
        
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(zoom, zoom);
            
            // Draw connections
            currentMap.connections.forEach(conn => conn.draw(ctx));
            
            // Draw stylo drawings
            if (currentMap.stylo_drawings) {
                currentMap.stylo_drawings.forEach(drawing => {
                    if (drawing.type === 'straight_line') {
                        ctx.strokeStyle = drawing.color;
                        ctx.lineWidth = drawing.size;
                        ctx.setLineDash([]);
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(drawing.x1, drawing.y1);
                        ctx.lineTo(drawing.x2, drawing.y2);
                        ctx.stroke();
                    }
                });
            }
            
            // Draw nodes
            currentMap.nodes.forEach(node => node.draw(ctx));
            
            // Draw connecting line if in connect mode
            if (isConnecting && connectStart) {
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(connectStart.x, connectStart.y);
                const rect = canvas.getBoundingClientRect();
                const mouseX = (lastMouseX - rect.left - panOffset.x) / zoom;
                const mouseY = (lastMouseY - rect.top - panOffset.y) / zoom;
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw pen drawing preview
            if (isDrawing && drawStart) {
                ctx.strokeStyle = selectedPenColor;
                ctx.lineWidth = selectedPenSize;
                ctx.setLineDash([]);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(drawStart.x, drawStart.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
            }
            
            // Draw selection rectangle
            if (isAreaSelecting) {
                const minX = Math.min(areaSelectStart.x, areaSelectEnd.x);
                const maxX = Math.max(areaSelectStart.x, areaSelectEnd.x);
                const minY = Math.min(areaSelectStart.y, areaSelectEnd.y);
                const maxY = Math.max(areaSelectStart.y, areaSelectEnd.y);
                
                // Fill background
                ctx.fillStyle = 'rgba(173, 216, 230, 0.2)'; // Light blue with transparency
                ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
                
                // Draw dotted border
                ctx.strokeStyle = '#4169e1'; // Royal blue
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                ctx.setLineDash([]);
            }
            
            // Highlight selected nodes
            selectedNodes.forEach(node => {
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.setLineDash([6, 3]);
                const padding = 8;
                const size = node.size || 16;
                const width = Math.max(node.text.length * 7 + 20, 80);
                const height = node.size * 2;
                
                if (node.shape === 'circle') {
                    const radius = node.type === 'central' ? node.size + 10 : Math.max(width, height) / 2;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius + padding, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (node.shape === 'triangle-down' || node.shape === 'triangle-up') {
                    // Highlight triangle with rectangular outline
                    const baseWidth = width * 0.8 + padding * 2;
                    const triangleHeight = height * 1.2 + padding * 2;
                    ctx.strokeRect(node.x - baseWidth/2, node.y - triangleHeight/2, baseWidth, triangleHeight);
                } else if (node.shape === 'pentagon') {
                    // Highlight pentagon with circular outline
                    const radius = Math.max(width, height) / 2 + padding;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Rectangle and default shapes
                    const highlightWidth = width + padding * 2;
                    const highlightHeight = height + padding * 2;
                    ctx.strokeRect(node.x - highlightWidth/2, node.y - highlightHeight/2, highlightWidth, highlightHeight);
                }
                ctx.setLineDash([]);
            });
            
            // Highlight selected connections
            selectedConnections.forEach(conn => {
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 4;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.moveTo(conn.startNode.x, conn.startNode.y);
                ctx.lineTo(conn.endNode.x, conn.endNode.y);
                ctx.stroke();
                ctx.setLineDash([]);
            });
            
            // Highlight selected stylo drawings
            selectedStyloDrawings.forEach(drawing => {
                if (drawing.type === 'straight_line') {
                    ctx.strokeStyle = '#ff6b35';
                    ctx.lineWidth = drawing.size + 4; // Thicker than original
                    ctx.setLineDash([6, 3]);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(drawing.x1, drawing.y1);
                    ctx.lineTo(drawing.x2, drawing.y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            ctx.restore();
            
            // Update stats
            updateStats();
            
            requestAnimationFrame(render);
        }
        
        let lastMouseX = 0, lastMouseY = 0;
        
        // Event Handlers
        function handleDoubleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoom;
            const y = (e.clientY - rect.top - panOffset.y) / zoom;
            
            const text = prompt(t('prompt.node.text'));
            if (text) {
                const node = new Node(x, y, text, 'concept');
                addNodeToMap(node);
            }
        }
        
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoom;
            const y = (e.clientY - rect.top - panOffset.y) / zoom;
            
            // If pen tool is selected, start drawing a line
            if (currentTool === 'pen') {
                isDrawing = true;
                drawStart = { x: x, y: y };
                return;
            }
            
            // If eraser tool is selected, check for stylo drawings to remove
            if (currentTool === 'eraser') {
                const clickedDrawing = findDrawingAtPoint(x, y);
                if (clickedDrawing) {
                    removeDrawing(clickedDrawing.id);
                    return;
                }
            }
            
            // If lasso tool is selected, start area selection
            if (currentTool === 'lasso') {
                // Check if clicking on selected nodes or stylo drawings for dragging
                let clickedSelectedItem = false;
                
                // Check selected nodes
                for (let node of selectedNodes) {
                    if (node.isPointInside(x, y)) {
                        isDraggingSelection = true;
                        selectionOffset.x = x;
                        selectionOffset.y = y;
                        clickedSelectedItem = true;
                        break;
                    }
                }
                
                // Check selected stylo drawings if no node was clicked
                if (!clickedSelectedItem) {
                    for (let drawing of selectedStyloDrawings) {
                        if (drawing.type === 'straight_line') {
                            const distance = distancePointToLine(x, y, drawing.x1, drawing.y1, drawing.x2, drawing.y2);
                            if (distance <= 10 + drawing.size / 2) {
                                isDraggingSelection = true;
                                selectionOffset.x = x;
                                selectionOffset.y = y;
                                clickedSelectedItem = true;
                                break;
                            }
                        }
                    }
                }
                
                if (!clickedSelectedItem) {
                    // Start new area selection
                    isAreaSelecting = true;
                    areaSelectStart.x = x;
                    areaSelectStart.y = y;
                    areaSelectEnd.x = x;
                    areaSelectEnd.y = y;
                    selectedNodes = [];
                    selectedConnections = [];
                }
                return;
            }
            
            // Check if clicking on a node
            selectedNode = null;
            for (let node of currentMap.nodes) {
                if (node.isPointInside(x, y)) {
                    selectedNode = node;
                    
                    if (currentTool === 'connect') {
                        if (!isConnecting) {
                            isConnecting = true;
                            connectStart = node;
                        } else {
                            // Complete connection
                            if (connectStart !== node) {
                                const conn = new Connection(connectStart, node, 'simple');
                                currentMap.connections.push(conn);
                                saveHistory();
                            }
                            isConnecting = false;
                            connectStart = null;
                        }
                    } else {
                        isDragging = true;
                        dragOffset.x = x - node.x;
                        dragOffset.y = y - node.y;
                        showPropertiesPanel(node);
                    }
                    return;
                }
            }
            
            // Check if clicking on an arrow/connection
            selectedConnection = null;
            for (let connection of currentMap.connections) {
                if (connection.isNearPoint(x, y)) {
                    selectedConnection = connection;
                    showArrowPropertiesPanel(connection);
                    return;
                }
            }
            
            // Pan with shift
            if (e.shiftKey) {
                canvas.style.cursor = 'grabbing';
            }
            
            // Hide properties if clicking empty space (but only hide the form, not the panel)
            selectedNode = null;
            selectedConnection = null;
            document.getElementById('node-form').style.display = 'none';
            document.getElementById('no-node-message').style.display = 'block';
            document.getElementById('arrow-form').style.display = 'none';
            document.getElementById('no-arrow-message').style.display = 'block';
            
            // Clear node name in title
            const nodeTitleElement = document.getElementById('node-title-name');
            if (nodeTitleElement) {
                nodeTitleElement.textContent = '';
            }
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - panOffset.x) / zoom;
            const y = (e.clientY - rect.top - panOffset.y) / zoom;
            
            // Update mouse position for pen drawing preview
            mouseX = x;
            mouseY = y;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            // Handle area selection
            if (isAreaSelecting) {
                areaSelectEnd.x = x;
                areaSelectEnd.y = y;
                return;
            }
            
            // Handle dragging selected items (nodes and stylo drawings)
            if (isDraggingSelection && (selectedNodes.length > 0 || selectedStyloDrawings.length > 0)) {
                const deltaX = x - selectionOffset.x;
                const deltaY = y - selectionOffset.y;
                
                // Move selected nodes
                for (let node of selectedNodes) {
                    node.x += deltaX;
                    node.y += deltaY;
                }
                
                // Move selected stylo drawings
                for (let drawing of selectedStyloDrawings) {
                    if (drawing.type === 'straight_line') {
                        drawing.x1 += deltaX;
                        drawing.y1 += deltaY;
                        drawing.x2 += deltaX;
                        drawing.y2 += deltaY;
                    }
                }
                
                selectionOffset.x = x;
                selectionOffset.y = y;
                return;
            }
            
            if (isDragging && selectedNode) {
                selectedNode.x = x - dragOffset.x;
                selectedNode.y = y - dragOffset.y;
            } else if (e.shiftKey && e.buttons === 1) {
                panOffset.x += e.movementX;
                panOffset.y += e.movementY;
            }
            
            // Update cursor
            let hovering = false;
            for (let node of currentMap.nodes) {
                if (node.isPointInside(x, y)) {
                    canvas.style.cursor = 'pointer';
                    hovering = true;
                    break;
                }
            }
            
            // Check for arrow hover if not hovering over a node
            if (!hovering) {
                for (let connection of currentMap.connections) {
                    if (connection.isNearPoint(x, y)) {
                        canvas.style.cursor = 'pointer';
                        hovering = true;
                        break;
                    }
                }
            }
            
            // Check for stylo drawing hover if using eraser tool
            if (!hovering && currentTool === 'eraser') {
                const drawingAtPoint = findDrawingAtPoint(x, y);
                if (drawingAtPoint) {
                    canvas.style.cursor = 'pointer';
                    hovering = true;
                }
            }
            
            if (!hovering && !e.shiftKey) {
                let cursorType = 'default';
                if (currentTool === 'lasso') cursorType = 'crosshair';
                else if (currentTool === 'eraser') cursorType = 'crosshair';
                canvas.style.cursor = cursorType;
            } else if (e.shiftKey) {
                canvas.style.cursor = 'grab';
            }
            
            // Re-render if drawing with pen to show preview
            if (isDrawing && currentTool === 'pen') {
                render();
            }
        }
        
        function handleMouseUp(e) {
            // Handle pen drawing completion
            if (isDrawing && drawStart) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - panOffset.x) / zoom;
                const y = (e.clientY - rect.top - panOffset.y) / zoom;
                
                // Create a new drawing line
                const drawing = {
                    id: `drawing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'straight_line',
                    x1: drawStart.x,
                    y1: drawStart.y,
                    x2: x,
                    y2: y,
                    size: selectedPenSize,
                    color: selectedPenColor
                };
                
                // Add to stylo_drawings array
                currentMap.stylo_drawings.push(drawing);
                
                // Reset drawing state
                isDrawing = false;
                drawStart = null;
                
                // Render and save
                render();
                saveHistory();
                autosave();
                
                return;
            }
            
            // Handle area selection completion
            if (isAreaSelecting) {
                isAreaSelecting = false;
                
                // Find nodes within selection rectangle
                const minX = Math.min(areaSelectStart.x, areaSelectEnd.x);
                const maxX = Math.max(areaSelectStart.x, areaSelectEnd.x);
                const minY = Math.min(areaSelectStart.y, areaSelectEnd.y);
                const maxY = Math.max(areaSelectStart.y, areaSelectEnd.y);
                
                selectedNodes = [];
                selectedConnections = [];
                selectedStyloDrawings = [];
                
                // Select nodes within area
                for (let node of currentMap.nodes) {
                    if (node.x >= minX && node.x <= maxX && 
                        node.y >= minY && node.y <= maxY) {
                        selectedNodes.push(node);
                    }
                }
                
                // Select connections that have both endpoints selected
                for (let connection of currentMap.connections) {
                    if (selectedNodes.includes(connection.startNode) && 
                        selectedNodes.includes(connection.endNode)) {
                        selectedConnections.push(connection);
                    }
                }
                
                // Select stylo drawings within area
                if (currentMap.stylo_drawings) {
                    for (let drawing of currentMap.stylo_drawings) {
                        if (drawing.type === 'straight_line') {
                            if (lineIntersectsRect(drawing.x1, drawing.y1, drawing.x2, drawing.y2, minX, minY, maxX, maxY)) {
                                selectedStyloDrawings.push(drawing);
                            }
                        }
                    }
                }
                
                console.log(`Selected ${selectedNodes.length} nodes, ${selectedConnections.length} connections, and ${selectedStyloDrawings.length} stylo drawings`);
                showDeleteForSelection();
                return;
            }
            
            // Handle selection dragging completion
            if (isDraggingSelection) {
                isDraggingSelection = false;
                saveHistory();
                if (autoSaveEnabled) autosave();
                showDeleteForSelection();
                return;
            }
            
            if (isDragging) {
                isDragging = false;
                saveHistory();
            }
            canvas.style.cursor = currentTool === 'lasso' ? 'crosshair' : 'default';
        }
        
        function handleWheel(e) {
            e.preventDefault();
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom *= scaleFactor;
            zoom = Math.max(0.3, Math.min(3, zoom));
        }
        
        function handleKeyDown(e) {
            if (e.key === 'Delete' && selectedNode) {
                deleteSelected();
            } else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveMap();
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        }
        
        // API-safe fetch wrapper (works when opened with file://)
        async function fetchApi(url, options = {}) {
            const isFile = window.location && window.location.protocol === 'file:';
            // If absolute URL, try direct fetch first
            if (/^https?:\/\//i.test(url)) {
                try { return await fetch(url, options); } catch (err) { if (!isFile) throw err; }
            }

            // If not absolute, try normal fetch (relative to origin) when not file://
            if (!isFile) {
                try {
                    // Try the path as-is (works when served via http)
                    return await fetch(url, options);
                } catch (err) {
                    // Try localhost fallback
                    try { return await fetch('http://localhost:5000' + url, options); } catch (err2) { throw err; }
                }
            }

            // file:// fallback mode -> emulate simple API using localStorage and in-memory templates
            try {
                const mapsStore = JSON.parse(localStorage.getItem('mindmaps') || '{}');

                // GET /api/maps
                if (url === '/api/maps') {
                    const mapsArr = Object.values(mapsStore);
                    return new Response(JSON.stringify({ success: true, maps: mapsArr }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                }

                // GET /api/map/:id
                const getMapMatch = url.match(/^\/api\/map\/([^\/\?]+)/);
                if (getMapMatch && (!options.method || options.method.toUpperCase() === 'GET')) {
                    const id = getMapMatch[1];
                    const map = mapsStore[id];
                    if (map) return new Response(JSON.stringify({ success: true, map }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                    return new Response(JSON.stringify({ success: false, error: 'not found' }), { status: 404, headers: { 'Content-Type': 'application/json' } });
                }

                // POST /api/map -> save or create
                if (url === '/api/map' && options.method && options.method.toUpperCase() === 'POST') {
                    const body = options.body ? JSON.parse(options.body) : {};
                    let id = body.id;
                    if (!id) {
                        const d = new Date();
                        const stamp = `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}_${String(d.getHours()).padStart(2,'0')}${String(d.getMinutes()).padStart(2,'0')}${String(d.getSeconds()).padStart(2,'0')}`;
                        id = `map_${stamp}_${Math.random().toString(36).substr(2,5)}`;
                    }
                    body.id = id;
                    body.modified = new Date().toISOString();
                    mapsStore[id] = body;
                    localStorage.setItem('mindmaps', JSON.stringify(mapsStore));
                    return new Response(JSON.stringify({ success: true, id }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                }

                // GET stats
                if (url === '/api/stats') {
                    const mapsArr = Object.values(mapsStore);
                    const stats = {
                        totalMaps: mapsArr.length,
                        totalNodes: mapsArr.reduce((s,m) => s + (m.nodes ? m.nodes.length : 0), 0),
                        grindeCount: mapsArr.filter(m => m.mode === 'grinde').length,
                        buzanCount: mapsArr.filter(m => m.mode === 'buzan').length
                    };
                    return new Response(JSON.stringify({ success: true, stats }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                }

                // POST /api/autosave
                if (url === '/api/autosave' && options.method && options.method.toUpperCase() === 'POST') {
                    const body = options.body ? JSON.parse(options.body) : null;
                    if (body && body.id) {
                        mapsStore[body.id] = body;
                        localStorage.setItem('mindmaps', JSON.stringify(mapsStore));
                        return new Response(JSON.stringify({ success: true }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                    }
                    return new Response(JSON.stringify({ success: false }), { status: 400, headers: { 'Content-Type': 'application/json' } });
                }

                // POST /api/map/:id/rename
                const renameMatch = url.match(/^\/api\/map\/([^\/]+)\/rename/);
                if (renameMatch && options.method && options.method.toUpperCase() === 'POST') {
                    const id = renameMatch[1];
                    const body = options.body ? JSON.parse(options.body) : {};
                    if (mapsStore[id]) {
                        mapsStore[id].title = body.title || mapsStore[id].title;
                        localStorage.setItem('mindmaps', JSON.stringify(mapsStore));
                        return new Response(JSON.stringify({ success: true }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                    }
                    return new Response(JSON.stringify({ success: false, error: 'not found' }), { status: 404, headers: { 'Content-Type': 'application/json' } });
                }

                // GET /api/template/:id -> try in-memory templates object if present
                const tmplMatch = url.match(/^\/api\/template\/(.+)/);
                if (tmplMatch) {
                    const templateId = tmplMatch[1];
                    if (typeof templates !== 'undefined' && templates[templateId]) {
                        return new Response(JSON.stringify({ success: true, data: templates[templateId] }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                    }
                    return new Response(JSON.stringify({ success: false, error: 'template not found' }), { status: 404, headers: { 'Content-Type': 'application/json' } });
                }

                // GET /api/settings -> return sensible defaults
                if (url === '/api/settings') {
                    return new Response(JSON.stringify({ autosave: { default: true, frequency_seconds: 60 } }), { status: 200, headers: { 'Content-Type': 'application/json' } });
                }

                return new Response(JSON.stringify({ success: false, error: 'not implemented in file mode' }), { status: 404, headers: { 'Content-Type': 'application/json' } });
            } catch (err) {
                return new Response(JSON.stringify({ success: false, error: err.message }), { status: 500, headers: { 'Content-Type': 'application/json' } });
            }
        }

        // Map Management
        function newMap() {
            if (currentMap.nodes.length > 0) {
                if (!confirm(t('confirm.new'))) {
                    return;
                }
            }
            
            currentMap = {
                id: null,
                title: t('app.title'),
                mode: document.querySelector('.mode-btn.active').classList.contains('grinde') ? 'grinde' : 'buzan',
                nodes: [],
                connections: []
            };
            
            // Add central node
            const centerX = canvas.width / 2 / zoom - panOffset.x / zoom;
            const centerY = canvas.height / 2 / zoom - panOffset.y / zoom;
            const centralNode = new Node(centerX, centerY, t('node.central'), 'central');
            currentMap.nodes.push(centralNode);
            
            history = [];
            historyIndex = -1;
            saveHistory();
        }
        
        async function saveMap() {
            // Use current title or default title without prompting
            if (!currentMap.title) {
                currentMap.title = t('app.title');
            }
            
            // Convert to plain objects for JSON
            const mapData = {
                id: currentMap.id,
                title: currentMap.title,
                mode: currentMap.mode,
                nodes: currentMap.nodes.map(n => ({
                    id: n.id,
                    x: n.x,
                    y: n.y,
                    text: n.text,
                    type: n.type,
                    size: n.size,
                    color: n.color,
                    shape: n.shape || n.getDefaultShape()
                })),
                connections: currentMap.connections.map(c => ({
                    source: c.source.id,
                    target: c.target.id,
                    type: c.type,
                    color: c.color,
                    text: c.text || ''
                })),
                stylo_drawings: currentMap.stylo_drawings || []
            };
            
            try {
                const response = await fetchApi('/api/map', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(mapData)
                });
                
                const result = await response.json();
                if (result.success) {
                    currentMap.id = result.id;
                    showToast(t('toast.saved'), 'success');
                    loadMapsList();
                    // Switch to "Mes Cartes" tab to show the saved map
                    showSidebarTab('maps');
                }
            } catch (error) {
                showToast(t('toast.error'), 'error');
            }
        }
        
        async function loadMapsList() {
            try {
                const response = await fetchApi('/api/maps');
                const result = await response.json();
                
                if (result.success) {
                    const mapList = document.getElementById('mapList');
                    mapList.innerHTML = result.maps.map(map => `
                        <div class="map-item ${map.id === currentMap.id ? 'active' : ''}" style="position: relative;">
                            <div onclick="loadMap('${map.id}')" style="flex: 1; cursor: pointer;">
                                <div class="map-item-title">${map.title}</div>
                                <div class="map-item-meta">
                                    <span>${map.nodeCount} ${t('stat.nodes').toLowerCase()}</span>
                                    <span>${map.mode}</span>
                                    <span class="map-date">üìÖ ${(() => {
                                        const dateMatch = map.id.match(/map_(\\d{8})_(\\d{6})/);
                                        if (dateMatch) {
                                            const dateStr = dateMatch[1];
                                            const timeStr = dateMatch[2];
                                            const year = dateStr.substring(0, 4);
                                            const month = dateStr.substring(4, 6);
                                            const day = dateStr.substring(6, 8);
                                            const hour = timeStr.substring(0, 2);
                                            const minute = timeStr.substring(2, 4);
                                            const date = new Date(year, month - 1, day, hour, minute);
                                            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                        }
                                        return map.createdAt ? new Date(map.createdAt).toLocaleDateString() : 'N/A';
                                    })()}</span>
                                </div>
                            </div>
                            <div class="map-item-actions">
                                <button class="map-action-btn rename" onclick="renameMap('${map.id}', '${map.title.replace(/'/g, "\\'")}')" title="Renommer">
                                    ‚úèÔ∏è
                                </button>
                                <button class="map-action-btn delete" onclick="deleteMap('${map.id}', '${map.title.replace(/'/g, "\\'")}')" title="Supprimer">
                                    üóëÔ∏è
                                </button>
                            </div>
                        </div>
                    `).join('');
                }
                
                // Load stats
                const statsResponse = await fetchApi('/api/stats');
                const stats = await statsResponse.json();
                if (stats.success) {
                    document.getElementById('globalStats').innerHTML = `
                        <div>Total: ${stats.stats.totalMaps} cartes</div>
                        <div>${t('stat.nodes')}: ${stats.stats.totalNodes}</div>
                        <div>GRINDE: ${stats.stats.grindeCount}</div>
                        <div>Buzan: ${stats.stats.buzanCount}</div>
                    `;
                }
            } catch (error) {
                console.error('Failed to load maps list');
            }
        }
        
        async function loadMostRecentMapOrNew() {
            try {
                const response = await fetchApi('/api/maps');
                const result = await response.json();
                
                if (result.success && result.maps && result.maps.length > 0) {
                    // Sort maps by creation date (most recent first)
                    const sortedMaps = result.maps.sort((a, b) => {
                        // Extract date from map ID format: map_YYYYMMDD_HHMMSS_xxxxx
                        const getDateFromId = (id) => {
                            const match = id.match(/map_(\d{8})_(\d{6})/);
                            if (match) {
                                const dateStr = match[1];
                                const timeStr = match[2];
                                const year = dateStr.substring(0, 4);
                                const month = dateStr.substring(4, 6);
                                const day = dateStr.substring(6, 8);
                                const hour = timeStr.substring(0, 2);
                                const minute = timeStr.substring(2, 4);
                                const second = timeStr.substring(4, 6);
                                return new Date(year, month - 1, day, hour, minute, second);
                            }
                            return new Date(0); // Fallback for invalid format
                        };
                        
                        const dateA = getDateFromId(a.id);
                        const dateB = getDateFromId(b.id);
                        return dateB.getTime() - dateA.getTime(); // Most recent first
                    });
                    
                    // Load the most recent map
                    const mostRecentMap = sortedMaps[0];
                    console.log('Loading most recent map:', mostRecentMap.id, mostRecentMap.title);
                    await loadMap(mostRecentMap.id);
                } else {
                    // No maps found, start with a new map
                    console.log('No maps found, starting with new map');
                    newMap();
                }
            } catch (error) {
                console.error('Failed to load most recent map:', error);
                // Fallback to new map on error
                newMap();
            }
        }
        
        async function renameMap(mapId, currentTitle) {
            const newTitle = prompt(t('prompt.rename.title'), currentTitle);
            if (newTitle && newTitle !== currentTitle) {
                try {
                    const response = await fetchApi(`/api/map/${mapId}/rename`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ title: newTitle })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        showToast(t('toast.renamed'), 'success');
                        
                        // Update current map title if it's the active map
                        if (currentMap.id === mapId) {
                            currentMap.title = newTitle;
                        }
                        
                        // Refresh the maps list
                        loadMapsList();
                    } else {
                        showToast(t('toast.error') + ': ' + result.error, 'error');
                    }
                } catch (error) {
                    console.error('Error renaming map:', error);
                    showToast(t('toast.error'), 'error');
                }
            }
        }
        
        async function deleteMap(mapId, mapTitle) {
            if (confirm(t('confirm.delete.map').replace('{title}', mapTitle))) {
                try {
                    const response = await fetchApi(`/api/map/${mapId}`, {
                        method: 'DELETE'
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        showToast(t('toast.deleted'), 'success');
                        
                        // If this was the current map, close it
                        if (currentMap.id === mapId) {
                            performMapClose();
                        }
                        
                        // Refresh the maps list
                        loadMapsList();
                    } else {
                        showToast(t('toast.error') + ': ' + result.error, 'error');
                    }
                } catch (error) {
                    console.error('Error deleting map:', error);
                    showToast(t('toast.error'), 'error');
                }
            }
        }
        
        async function loadMap(mapId) {
            try {
                const response = await fetchApi(`/api/map/${mapId}`);
                const result = await response.json();
                
                if (result.success) {
                    const data = result.data;
                    
                    // Reconstruct nodes
                    const nodeMap = {};
                    currentMap.nodes = data.nodes.map(n => {
                        const node = new Node(n.x, n.y, n.text, n.type);
                        node.id = n.id;
                        node.size = n.size;
                        node.color = n.color;
                        node.shape = n.shape || node.getDefaultShape(); // Backward compatibility
                        nodeMap[n.id] = node;
                        return node;
                    });
                    
                    // Reconstruct connections
                    currentMap.connections = data.connections.map(c => {
                        const conn = new Connection(nodeMap[c.source], nodeMap[c.target], c.type);
                        conn.color = c.color;
                        conn.text = c.text || '';
                        return conn;
                    });
                    
                    // Load stylo drawings
                    currentMap.stylo_drawings = data.stylo_drawings || [];
                    
                    currentMap.id = data.id;
                    currentMap.title = data.title;
                    currentMap.mode = data.mode;
                    
                    setMode(currentMap.mode);
                    render(); // Render the canvas to display all loaded elements including stylo drawings
                    showToast(t('toast.loaded'), 'success');
                    
                    // Update sidebar
                    loadMapsList();
                }
            } catch (error) {
                showToast(t('toast.error'), 'error');
            }
        }
        
        function loadMapDialog() {
            // Show the modal
            const modal = document.getElementById('loadMapModal');
            modal.style.display = 'block';
            modal.classList.add('active');
            
            // Load available maps
            loadAvailableMaps();
        }
        
        async function loadAvailableMaps() {
            const mapsList = document.getElementById('mapsList');
            mapsList.innerHTML = `<p data-i18n="load.loading">${t('load.loading')}</p>`;
            
            try {
                const response = await fetchApi('/api/maps');
                if (!response.ok) throw new Error('Failed to fetch maps');
                
                const result = await response.json();
                const maps = result.maps || [];
                
                if (maps.length === 0) {
                    mapsList.innerHTML = `<p data-i18n="load.no_maps">${t('load.no_maps')}</p>`;
                    return;
                }
                
                let html = `<p data-i18n="load.select">${t('load.select')}</p><div class="maps-grid">`;
                
                maps.forEach(map => {
                    const date = map.modified ? new Date(map.modified).toLocaleDateString() : 'Date inconnue';
                    const nodeCount = map.nodeCount || 0;
                    const mode = map.mode || 'grinde';
                    const modeLabel = mode.toUpperCase();
                    
                    html += `
                        <div class="map-item" onclick="selectMapToLoad('${map.id}', '${map.title}')">
                            <div class="map-title">${map.title}</div>
                            <div class="map-date">${date}</div>
                            <div class="map-nodes">${nodeCount} n≈ìuds ‚Ä¢ ${modeLabel}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
                mapsList.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading maps:', error);
                mapsList.innerHTML = '<p style="color: red;">Erreur lors du chargement des cartes</p>';
            }
        }
        
        function selectMapToLoad(mapId, title) {
            if (confirm(t('load.confirm'))) {
                // Show loading state
                const mapsList = document.getElementById('mapsList');
                mapsList.innerHTML = `<p data-i18n="load.loading">${t('load.loading')}</p>`;
                
                // Load map and close modal on success
                loadMapAndCloseModal(mapId);
            }
        }
        
        async function loadMapAndCloseModal(mapId) {
            try {
                console.log('Loading map with ID:', mapId);
                const response = await fetchApi(`/api/map/${mapId}`);
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('API result:', result);
                
                if (result.success) {
                    const data = result.data;
                    
                    // Reconstruct nodes
                    const nodeMap = {};
                    currentMap.nodes = data.nodes.map(n => {
                        const node = new Node(n.x, n.y, n.text, n.type);
                        node.id = n.id;
                        node.size = n.size;
                        node.color = n.color;
                        nodeMap[n.id] = node;
                        return node;
                    });
                    
                    // Reconstruct connections
                    currentMap.connections = data.connections.map(c => {
                        const conn = new Connection(nodeMap[c.source], nodeMap[c.target], c.type);
                        conn.color = c.color;
                        return conn;
                    });
                    
                    // Load stylo drawings
                    currentMap.stylo_drawings = data.stylo_drawings || [];
                    
                    currentMap.id = data.id;
                    currentMap.title = data.title;
                    currentMap.mode = data.mode;
                    
                    setMode(currentMap.mode);
                    render(); // Render the canvas to display all loaded elements including stylo drawings
                    showToast(t('toast.loaded'), 'success');
                    
                    // Update sidebar
                    loadMapsList();
                    
                    // Close the modal after successful loading
                    closeModal('loadMapModal');
                } else {
                    console.error('API returned error:', result.error);
                    showToast('Erreur: ' + (result.error || 'Carte non trouv√©e'), 'error');
                    // Reload the maps list if there was an error
                    loadAvailableMaps();
                }
            } catch (error) {
                console.error('Error loading map:', error);
                showToast('Erreur lors du chargement: ' + error.message, 'error');
                // Reload the maps list if there was an error
                loadAvailableMaps();
            }
        }
        
        async function duplicateMap() {
            if (!currentMap.id) {
                showToast(t('toast.error'), 'error');
                return;
            }
            
            try {
                const response = await fetchApi(`/api/map/${currentMap.id}/duplicate`, {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    await loadMap(result.id);
                    showToast(t('toast.saved'), 'success');
                }
            } catch (error) {
                showToast(t('toast.error'), 'error');
            }
        }
        
        function closeMap() {
            // Check if there's a current map
            if (!currentMap.id && currentMap.nodes.length === 0) {
                showToast('Aucune carte ouverte / No map open', 'info');
                return;
            }
            
            // If there are unsaved changes (for now, we'll assume all maps might have changes)
            // In a more sophisticated version, you'd track if the map has been modified
            const shouldSave = confirm(t('confirm.save_before_close'));
            
            if (shouldSave) {
                // Save the map first, then close
                saveMap().then(() => {
                    performMapClose();
                }).catch(() => {
                    // If save fails, ask if they still want to close
                    if (confirm(t('confirm.close'))) {
                        performMapClose();
                    }
                });
            } else {
                // Confirm closing without saving
                if (confirm(t('confirm.close'))) {
                    performMapClose();
                }
            }
        }
        
        function performMapClose() {
            // Reset the current map to empty state
            currentMap.id = null;
            currentMap.title = 'Nouvelle Carte Mentale';
            currentMap.mode = 'grinde';
            currentMap.nodes = [];
            currentMap.connections = [];
            
            // Reset the mode
            setMode('grinde');
            
            // Clear selection
            selectedNode = null;
            
            // Clear any UI state
            updateStats();
            
            // Update sidebar
            loadMapsList();
            
            // Show confirmation
            showToast(t('toast.closed'), 'info');
        }
        
        async function exportMap(format) {
            console.log('Export called with format:', format);
            console.log('Current map:', currentMap);
            console.log('Current map ID:', currentMap?.id);
            
            if (!currentMap || currentMap.nodes.length === 0) {
                console.error('No current map or empty map');
                showToast('Aucune carte √† exporter / No map to export', 'error');
                return;
            }
            
            // If map hasn't been saved yet, save it first
            if (!currentMap.id) {
                console.log('Map not saved yet, saving first...');
                showToast('Sauvegarde avant export... / Saving before export...', 'info');
                await saveMap();
                
                // Check if save was successful
                if (!currentMap.id) {
                    console.error('Save failed, cannot export');
                    showToast('√âchec de la sauvegarde / Save failed', 'error');
                    return;
                }
            }
            
            try {
                const exportUrl = `/api/export/${currentMap.id}/${format}`;
                console.log('Opening export URL:', exportUrl);
                window.open(exportUrl, '_blank');
                showToast(`Export ${format.toUpperCase()} d√©marr√© / ${format.toUpperCase()} export started`, 'success');
            } catch (error) {
                console.error('Export error:', error);
                showToast('Erreur lors de l\'export / Export error', 'error');
            }
        }
        
        // Node Management
        function addNode(type) {
            const centerX = canvas.width / 2 / zoom - panOffset.x / zoom;
            const centerY = canvas.height / 2 / zoom - panOffset.y / zoom;
            
            const promptKey = `prompt.node.${type}`;
            const text = prompt(t(promptKey));
            if (text) {
                const node = new Node(
                    centerX + Math.random() * 100 - 50,
                    centerY + Math.random() * 100 - 50,
                    text,
                    type
                );
                
                currentMap.nodes.push(node);
                
                // Auto-connect to selected node first, or central if no selection
                if (selectedNode) {
                    const conn = new Connection(selectedNode, node);
                    currentMap.connections.push(conn);
                } else if (node.type !== 'central' && currentMap.nodes.length > 1) {
                    const central = currentMap.nodes.find(n => n.type === 'central');
                    if (central) {
                        const conn = new Connection(central, node);
                        currentMap.connections.push(conn);
                    }
                }
                
                saveHistory();
                autosave();
            }
        }
        
        function addNodeToMap(node) {
            currentMap.nodes.push(node);
            
            // Auto-connect to selected node first, or central if no selection
            if (selectedNode) {
                const conn = new Connection(selectedNode, node);
                currentMap.connections.push(conn);
            } else if (node.type !== 'central' && currentMap.nodes.length > 1) {
                const central = currentMap.nodes.find(n => n.type === 'central');
                if (central) {
                    const conn = new Connection(central, node);
                    currentMap.connections.push(conn);
                }
            }
            
            saveHistory();
            autosave();
        }
        
        function quickAddNode(type) {
            const centerX = canvas.width / 2 / zoom - panOffset.x / zoom;
            const centerY = canvas.height / 2 / zoom - panOffset.y / zoom;
            
            const promptKey = `prompt.node.${type}`;
            const text = prompt(t(promptKey));
            if (text) {
                const node = new Node(
                    centerX + Math.random() * 200 - 100,
                    centerY + Math.random() * 200 - 100,
                    text,
                    type
                );
                
                currentMap.nodes.push(node);
                
                // Auto-connect to selected or central
                if (selectedNode) {
                    const conn = new Connection(selectedNode, node);
                    currentMap.connections.push(conn);
                } else {
                    const central = currentMap.nodes.find(n => n.type === 'central');
                    if (central) {
                        const conn = new Connection(central, node);
                        currentMap.connections.push(conn);
                    }
                }
                
                saveHistory();
                autosave();
            }
            
            // Close FAB menu
            document.getElementById('fabMenu').classList.remove('active');
        }
        
        function deleteSelected() {
            if (selectedNode) {
                if (confirm(t('confirm.delete'))) {
                    currentMap.nodes = currentMap.nodes.filter(n => n !== selectedNode);
                    currentMap.connections = currentMap.connections.filter(
                        c => c.source !== selectedNode && c.target !== selectedNode
                    );
                    selectedNode = null;
                    // Hide the form but keep the panel open
                    document.getElementById('node-form').style.display = 'none';
                    document.getElementById('no-node-message').style.display = 'block';
                    
                    // Clear node name in title
                    const nodeTitleElement = document.getElementById('node-title-name');
                    if (nodeTitleElement) {
                        nodeTitleElement.textContent = '';
                    }
                    
                    saveHistory();
                    autosave();
                }
            }
        }

        // Delete multiple selected nodes (used by lasso selection)
        function deleteSelectedNodes() {
            if (!selectedNodes || selectedNodes.length === 0) return;

            if (!confirm(t('confirm.delete_multiple') || 'Delete selected items?')) return;

            // Remove nodes
            const idsToRemove = new Set(selectedNodes.map(n => n.id));
            currentMap.nodes = currentMap.nodes.filter(n => !idsToRemove.has(n.id));

            // Remove connections that reference removed nodes
            currentMap.connections = currentMap.connections.filter(c => {
                const sourceId = c.source || c.sourceId || (c.startNode && c.startNode.id);
                const targetId = c.target || c.targetId || (c.endNode && c.endNode.id);
                return !(idsToRemove.has(sourceId) || idsToRemove.has(targetId));
            });

            // Remove stylo drawings associated with removed nodes (if any link exists)
            if (currentMap.stylo_drawings) {
                currentMap.stylo_drawings = currentMap.stylo_drawings.filter(d => {
                    // keep drawings not referencing removed node ids
                    return !(idsToRemove.has(d.sourceId) || idsToRemove.has(d.targetId));
                });
            }

            // Clear selection and UI
            selectedNodes = [];
            selectedConnections = [];
            selectedStyloDrawings = [];
            document.getElementById('selectionDeleteBtn').style.display = 'none';

            saveHistory();
            autosave();
        }

        function showDeleteForSelection() {
            const btn = document.getElementById('selectionDeleteBtn');
            if (!btn) return;

            if (currentTool === 'lasso' && selectedNodes && selectedNodes.length > 0) {
                // Position button near the top-right of the first selected node's bounding box
                const node = selectedNodes[0];
                const canvasRect = canvas.getBoundingClientRect();
                const x = canvasRect.left + (node.x + panOffset.x) * zoom + 10;
                const y = canvasRect.top + (node.y + panOffset.y) * zoom - 30;
                btn.style.left = `${x}px`;
                btn.style.top = `${y}px`;
                btn.style.display = 'block';
            } else {
                btn.style.display = 'none';
            }
        }

        // Key handler to delete selection when lasso active
        window.addEventListener('keydown', function(e) {
            if ((e.key === 'Delete' || e.key === 'Backspace') && currentTool === 'lasso' && selectedNodes.length > 0) {
                e.preventDefault();
                deleteSelectedNodes();
            }
        });

        // Attach click handler to floating delete button
        document.addEventListener('click', function(e) {
            const btn = document.getElementById('selectionDeleteBtn');
            if (e.target === btn) {
                deleteSelectedNodes();
            }
        });
        
        // Properties Panel
        function showPropertiesPanel(node) {
            // Show right panel if hidden
            const rightPanel = document.getElementById('rightPanel');
            if (rightPanel.classList.contains('hidden')) {
                toggleRightPanel();
            }
            
            // Switch to nodes tab
            showRightPanelTab('nodes');
            
            // Show the node form and hide no-selection message
            document.getElementById('node-form').style.display = 'block';
            document.getElementById('no-node-message').style.display = 'none';
            
            // Update the title with node name
            const nodeTitleElement = document.getElementById('node-title-name');
            if (nodeTitleElement) {
                nodeTitleElement.textContent = node.text ? `- "${node.text}"` : '';
            }
            
            // Save original properties for potential cancel operation
            originalNodeProperties = {
                text: node.text,
                size: node.size,
                shape: node.shape,
                color: node.color,
                textColor: node.textColor,
                shapeWidth: node.shapeWidth,
                shapeHeight: node.shapeHeight
            };
            
            document.getElementById('nodeText').value = node.text;
            document.getElementById('nodeSize').value = node.size;
            document.getElementById('nodeShape').value = node.shape || node.getDefaultShape();
            document.getElementById('nodeTextColor').value = node.textColor || '#000000';
            
            // Initialize size display
            document.getElementById('sizeValueDisplay').textContent = node.size;
            
            // Initialize shape size controls
            const shapeWidth = node.shapeWidth || node.getDefaultShapeWidth();
            const shapeHeight = node.shapeHeight || node.getDefaultShapeHeight();
            document.getElementById('shapeWidth').value = shapeWidth;
            document.getElementById('shapeHeight').value = shapeHeight;
            document.getElementById('shapeWidthDisplay').textContent = Math.round(shapeWidth);
            document.getElementById('shapeHeightDisplay').textContent = Math.round(shapeHeight);
            
            // Highlight selected color
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.style.background === node.color) {
                    opt.classList.add('selected');
                }
            });
            
            // Update shape preview
            updateShapePreview();
        }
        
        function closePropertiesPanel() {
            // Hide the node form and show no-selection message
            document.getElementById('node-form').style.display = 'none';
            document.getElementById('no-node-message').style.display = 'block';
            selectedNode = null;
            
            // Clear node name in title
            const nodeTitleElement = document.getElementById('node-title-name');
            if (nodeTitleElement) {
                nodeTitleElement.textContent = '';
            }
        }
        
        // Arrow Properties Panel
        function showArrowPropertiesPanel(connection) {
            selectedConnection = connection;
            
            // Show the right panel and switch to arrows tab
            const rightPanel = document.getElementById('rightPanel');
            if (rightPanel.classList.contains('hidden')) {
                toggleRightPanel();
            }
            showRightPanelTab('arrows');
            
            // Show the arrow form and hide the no-selection message
            document.getElementById('arrow-form').style.display = 'block';
            document.getElementById('no-arrow-message').style.display = 'none';
            
            document.getElementById('arrowId').value = connection.id;
            document.getElementById('arrowText').value = connection.text || '';
        }
        
        function closeArrowPropertiesPanel() {
            // Hide the arrow form and show the no-selection message
            document.getElementById('arrow-form').style.display = 'none';
            document.getElementById('no-arrow-message').style.display = 'block';
            selectedConnection = null;
        }
        
        function saveArrowProperties() {
            if (selectedConnection) {
                selectedConnection.text = document.getElementById('arrowText').value;
                saveHistory();
                autosave();
                closeArrowPropertiesPanel();
                showToast(t('toast.saved'), 'success');
            }
        }
        
        function cancelArrowProperties() {
            closeArrowPropertiesPanel();
        }
        
        // Score Modal Functions
        function showScoreModal() {
            calculateMapScore();
            document.getElementById('scoreModal').style.display = 'block';
        }
        
        function closeScoreModal() {
            document.getElementById('scoreModal').style.display = 'none';
        }
        
        function showScoreDetails() {
            showScoreModal();
        }
        
        function exportScoreReport() {
            const scoreData = calculateMapScore();
            const report = generateScoreReport(scoreData);
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mindmap-score-report-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast(t('toast.exported'), 'success');
        }
        
        function calculateMapScore() {
            const nodes = currentMap.nodes;
            const connections = currentMap.connections;
            
            // Calculate structure score (0-100)
            const structureScore = Math.min(100, (nodes.length * 10) + (connections.length * 5));
            
            // Calculate balance score based on node distribution
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            let balanceScore = 100;
            
            if (nodes.length > 1) {
                const distances = nodes.map(node => {
                    const dx = node.x - centerX;
                    const dy = node.y - centerY;
                    return Math.sqrt(dx * dx + dy * dy);
                });
                const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
                const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;
                balanceScore = Math.max(50, 100 - (variance / 1000));
            }
            
            // Calculate depth score based on connection complexity
            const depthScore = Math.min(100, connections.length * 20);
            
            // Calculate connections score
            const connectionsScore = nodes.length > 0 ? Math.min(100, (connections.length / nodes.length) * 100) : 0;
            
            // Overall score (weighted average)
            const overallScore = Math.round(
                (structureScore * 0.3) + 
                (balanceScore * 0.25) + 
                (depthScore * 0.2) + 
                (connectionsScore * 0.25)
            );
            
            // Update UI
            document.getElementById('overallScore').textContent = overallScore;
            updateScoreDescription(overallScore);
            updateScoreBars(structureScore, balanceScore, depthScore, connectionsScore);
            
            return {
                overall: overallScore,
                structure: structureScore,
                balance: Math.round(balanceScore),
                depth: Math.round(depthScore),
                connections: Math.round(connectionsScore),
                nodeCount: nodes.length,
                connectionCount: connections.length
            };
        }
        
        function updateScoreDescription(score) {
            const description = document.querySelector('.score-description');
            if (score >= 90) {
                description.textContent = t('score.excellent') || 'Excellent';
                description.style.color = '#059669';
            } else if (score >= 80) {
                description.textContent = t('score.very_good') || 'Tr√®s Bon';
                description.style.color = '#0891b2';
            } else if (score >= 70) {
                description.textContent = t('score.good') || 'Bon';
                description.style.color = '#ca8a04';
            } else if (score >= 60) {
                description.textContent = t('score.fair') || 'Correct';
                description.style.color = '#ea580c';
            } else {
                description.textContent = t('score.needs_improvement') || '√Ä Am√©liorer';
                description.style.color = '#dc2626';
            }
        }
        
        function updateScoreBars(structure, balance, depth, connections) {
            const bars = document.querySelectorAll('.score-fill');
            const numbers = document.querySelectorAll('.score-number');
            const scores = [structure, balance, depth, connections];
            
            scores.forEach((score, index) => {
                if (bars[index] && numbers[index]) {
                    bars[index].style.width = `${score}%`;
                    numbers[index].textContent = `${Math.round(score)}%`;
                    
                    // Color coding for score bars
                    if (score >= 80) {
                        bars[index].style.background = 'linear-gradient(90deg, #10b981, #059669)';
                    } else if (score >= 60) {
                        bars[index].style.background = 'linear-gradient(90deg, #f59e0b, #d97706)';
                    } else {
                        bars[index].style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
                    }
                }
            });
        }
        
        function generateScoreReport(scoreData) {
            const timestamp = new Date().toLocaleString();
            return `RAPPORT D'ANALYSE DE CARTE MENTALE
Generated: ${timestamp}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SCORES D√âTAILL√âS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Score Global: ${scoreData.overall}/100
Structure: ${scoreData.structure}/100
√âquilibre: ${scoreData.balance}/100
Profondeur: ${scoreData.depth}/100
Connexions: ${scoreData.connections}/100

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
STATISTIQUES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Nombre de n≈ìuds: ${scoreData.nodeCount}
Nombre de connexions: ${scoreData.connectionCount}
Ratio connexions/n≈ìuds: ${(scoreData.connectionCount / scoreData.nodeCount).toFixed(2)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
RECOMMANDATIONS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

${scoreData.overall >= 90 ? 'Excellente carte mentale! Structure tr√®s bien organis√©e.' :
  scoreData.overall >= 80 ? 'Tr√®s bonne carte mentale. Quelques am√©liorations mineures possibles.' :
  scoreData.overall >= 70 ? 'Bonne carte mentale. Consid√©rez ajouter plus de connexions.' :
  scoreData.overall >= 60 ? 'Carte correcte. Am√©liorez l\'√©quilibre et ajoutez plus de contenu.' :
  'Carte √† am√©liorer. Ajoutez plus de n≈ìuds et √©quilibrez la structure.'}

${scoreData.structure < 70 ? '‚Ä¢ Ajoutez plus de n≈ìuds pour enrichir le contenu\n' : ''}${scoreData.balance < 70 ? '‚Ä¢ R√©√©quilibrez la r√©partition des n≈ìuds\n' : ''}${scoreData.depth < 70 ? '‚Ä¢ Cr√©ez plus de connexions entre les n≈ìuds\n' : ''}${scoreData.connections < 70 ? '‚Ä¢ √âtoffez les relations entre les concepts\n' : ''}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Mind Map Mini - Score Analysis Report
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`;
        }
        
        function updateNodeProperty(property) {
            if (selectedNode) {
                if (property === 'text') {
                    selectedNode.text = document.getElementById('nodeText').value;
                } else if (property === 'size') {
                    selectedNode.size = parseInt(document.getElementById('nodeSize').value);
                } else if (property === 'shape') {
                    selectedNode.shape = document.getElementById('nodeShape').value;
                }
                saveHistory();
                autosave();
            }
        }
        
        // Node Properties Panel Functions
        let originalNodeProperties = {};
        
        function saveNodeProperties() {
            if (selectedNode) {
                selectedNode.text = document.getElementById('nodeText').value;
                selectedNode.size = parseInt(document.getElementById('nodeSize').value);
                selectedNode.shape = document.getElementById('nodeShape').value;
                selectedNode.textColor = document.getElementById('nodeTextColor').value;
                selectedNode.shapeWidth = parseInt(document.getElementById('shapeWidth').value);
                selectedNode.shapeHeight = parseInt(document.getElementById('shapeHeight').value);
                
                render();
                saveHistory();
                autosave();
                closePropertiesPanel();
                showToast(t('toast.saved'), 'success');
            }
        }
        
        function cancelNodeProperties() {
            if (selectedNode && originalNodeProperties) {
                // Restore original properties
                selectedNode.text = originalNodeProperties.text || selectedNode.text;
                selectedNode.size = originalNodeProperties.size || selectedNode.size;
                selectedNode.shape = originalNodeProperties.shape || selectedNode.shape;
                selectedNode.color = originalNodeProperties.color || selectedNode.color;
                selectedNode.textColor = originalNodeProperties.textColor || selectedNode.textColor;
                selectedNode.shapeWidth = originalNodeProperties.shapeWidth || selectedNode.shapeWidth;
                selectedNode.shapeHeight = originalNodeProperties.shapeHeight || selectedNode.shapeHeight;
                
                // Update the display to reflect restored values
                document.getElementById('sizeValueDisplay').textContent = selectedNode.size;
                document.getElementById('nodeSize').value = selectedNode.size;
                document.getElementById('nodeShape').value = selectedNode.shape;
                document.getElementById('nodeText').value = selectedNode.text;
                document.getElementById('nodeTextColor').value = selectedNode.textColor || '#000000';
                
                // Update shape size controls
                const shapeWidth = selectedNode.shapeWidth || selectedNode.getDefaultShapeWidth();
                const shapeHeight = selectedNode.shapeHeight || selectedNode.getDefaultShapeHeight();
                document.getElementById('shapeWidth').value = shapeWidth;
                document.getElementById('shapeHeight').value = shapeHeight;
                document.getElementById('shapeWidthDisplay').textContent = Math.round(shapeWidth);
                document.getElementById('shapeHeightDisplay').textContent = Math.round(shapeHeight);
                
                // Force a re-render to show the restored changes immediately
                render();
            }
            closePropertiesPanel();
        }
        
        function updateSizeDisplay() {
            const sizeSlider = document.getElementById('nodeSize');
            const sizeDisplay = document.getElementById('sizeValueDisplay');
            const newSize = parseInt(sizeSlider.value);
            
            // Update display
            sizeDisplay.textContent = newSize;
            
            // Apply size change to selected node for immediate visual feedback
            if (selectedNode) {
                selectedNode.size = newSize;
                // Force a re-render to show the change immediately
                render();
                // Note: We don't save to history/autosave here - only when "Enregistrer" is clicked
            }
        }
        
        function updateTextColor() {
            const textColorSelect = document.getElementById('nodeTextColor');
            const newTextColor = textColorSelect.value;
            
            // Apply text color change to selected node for immediate visual feedback
            if (selectedNode) {
                selectedNode.textColor = newTextColor;
                // Force a re-render to show the change immediately
                render();
                // Note: We don't save to history/autosave here - only when "Enregistrer" is clicked
            }
        }
        
        function updateShapePreview() {
            const shapeSelect = document.getElementById('nodeShape');
            const newShape = shapeSelect.value;
            
            // Apply shape change to selected node for immediate visual feedback
            if (selectedNode) {
                selectedNode.shape = newShape;
                // Force a re-render to show the change immediately
                render();
                // Note: We don't save to history/autosave here - only when "Enregistrer" is clicked
            }
        }
        
        function updateShapeSize() {
            const widthSlider = document.getElementById('shapeWidth');
            const heightSlider = document.getElementById('shapeHeight');
            const widthDisplay = document.getElementById('shapeWidthDisplay');
            const heightDisplay = document.getElementById('shapeHeightDisplay');
            
            const newWidth = parseInt(widthSlider.value);
            const newHeight = parseInt(heightSlider.value);
            
            // Update displays
            widthDisplay.textContent = newWidth;
            heightDisplay.textContent = newHeight;
            
            // Apply shape size changes to selected node for immediate visual feedback
            if (selectedNode) {
                selectedNode.shapeWidth = newWidth;
                selectedNode.shapeHeight = newHeight;
                console.log('Updated shape size:', selectedNode.shapeWidth, selectedNode.shapeHeight);
                // Force a re-render to show the change immediately
                render();
                // Note: We don't save to history/autosave here - only when "Enregistrer" is clicked
            }
        }
        
        function setNodeColor(color) {
            if (selectedNode) {
                selectedNode.color = color;
                document.querySelectorAll('.color-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                event.target.classList.add('selected');
                saveHistory();
                autosave();
            }
        }
        
        // Mode and Tools
        function setMode(mode) {
            currentMap.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-btn.${mode}`).classList.add('active');
            document.getElementById('currentMode').textContent = mode.toUpperCase();
            
            // Update principles list if principles tab is visible
            const principlesTab = document.getElementById('principles-tab');
            if (principlesTab && principlesTab.style.display !== 'none') {
                updatePrinciplesList();
            }
        }
        
        function setTool(tool) {
            currentTool = tool;
            isConnecting = false;
            connectStart = null;
            
            // Clear selections when switching tools
            if (tool !== 'lasso') {
                selectedNodes = [];
                selectedConnections = [];
                selectedStyloDrawings = [];
                isAreaSelecting = false;
                isDraggingSelection = false;
                showDeleteForSelection();
            }
            
            // Update cursor based on tool
            const canvas = document.getElementById('canvas');
            if (tool === 'lasso') {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'default';
            }
        }
        
        // View Controls
        function zoomIn() {
            zoom = Math.min(zoom * 1.2, 3);
        }
        
        function zoomOut() {
            zoom = Math.max(zoom * 0.8, 0.3);
        }
        
        function resetView() {
            zoom = 1;
            panOffset = { x: 0, y: 0 };
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const checkmark = document.getElementById('sidebarCheckmark');
            
            sidebar.classList.toggle('hidden');
            sidebarVisible = !sidebar.classList.contains('hidden');
            
            // Update checkmark visibility
            if (sidebarVisible) {
                checkmark.classList.remove('hidden');
            } else {
                checkmark.classList.add('hidden');
            }
        }
        
        function initSidebarToggle() {
            const sidebar = document.getElementById('sidebar');
            const checkmark = document.getElementById('sidebarCheckmark');
            
            // Set initial state based on sidebar visibility
            sidebarVisible = !sidebar.classList.contains('hidden');
            
            // Update checkmark to match current state
            if (sidebarVisible) {
                checkmark.classList.remove('hidden');
            } else {
                checkmark.classList.add('hidden');
            }
        }
        
        function toggleTools() {
            console.log('toggleTools called');
            const toolsContainer = document.getElementById('toolsContainer');
            const checkmark = document.getElementById('toolsCheckmark');
            
            console.log('toolsContainer:', toolsContainer);
            console.log('checkmark:', checkmark);
            
            if (toolsContainer) {
                toolsContainer.classList.toggle('hidden');
                toolsVisible = !toolsContainer.classList.contains('hidden');
                console.log('toolsVisible:', toolsVisible);
                
                // Update checkmark visibility
                if (toolsVisible) {
                    checkmark.classList.remove('hidden');
                } else {
                    checkmark.classList.add('hidden');
                }
            } else {
                console.error('toolsContainer not found');
            }
        }
        
        function initToolsToggle() {
            const toolsContainer = document.getElementById('toolsContainer');
            const checkmark = document.getElementById('toolsCheckmark');
            
            // Set initial state based on tools container visibility
            toolsVisible = !toolsContainer.classList.contains('hidden');
            
            // Update checkmark to match current state
            if (toolsVisible) {
                checkmark.classList.remove('hidden');
            } else {
                checkmark.classList.add('hidden');
            }
        }
        
        function toggleRightPanel() {
            console.log('toggleRightPanel called');
            const rightPanel = document.getElementById('rightPanel');
            const checkmark = document.getElementById('rightPanelCheckmark');
            
            console.log('rightPanel:', rightPanel);
            console.log('checkmark:', checkmark);
            
            if (rightPanel) {
                rightPanel.classList.toggle('hidden');
                rightPanelVisible = !rightPanel.classList.contains('hidden');
                console.log('rightPanelVisible:', rightPanelVisible);
                
                // Update checkmark visibility
                if (rightPanelVisible) {
                    checkmark.classList.remove('hidden');
                } else {
                    checkmark.classList.add('hidden');
                }
            } else {
                console.error('rightPanel not found');
            }
        }
        
        function initRightPanelToggle() {
            const rightPanel = document.getElementById('rightPanel');
            const checkmark = document.getElementById('rightPanelCheckmark');
            
            // Set initial state based on right panel visibility
            rightPanelVisible = !rightPanel.classList.contains('hidden');
            
            // Update checkmark to match current state
            if (rightPanelVisible) {
                checkmark.classList.remove('hidden');
            } else {
                checkmark.classList.add('hidden');
            }
        }
        
        function showRightPanelTab(tab) {
            // Hide all right panel tabs
            document.querySelectorAll('#rightPanel .sidebar-pane').forEach(pane => {
                pane.style.display = 'none';
            });
            
            // Show selected tab
            document.getElementById(`${tab}-tab`).style.display = 'block';
            
            // Update tab buttons - remove active from all right panel tabs
            document.querySelectorAll('#rightPanel .sidebar-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active to the correct tab by finding the button that calls this function for the specified tab
            const targetButton = document.querySelector(`#rightPanel [onclick="showRightPanelTab('${tab}')"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }
        }
        
        function showSidebarTab(tab) {
            // Hide all tabs
            document.querySelectorAll('.sidebar-pane').forEach(pane => {
                pane.style.display = 'none';
            });
            
            // Show selected tab
            document.getElementById(`${tab}-tab`).style.display = 'block';
            
            // Update tab buttons - remove active from all
            document.querySelectorAll('.sidebar-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active to the correct tab
            const targetButton = document.querySelector(`[onclick="showSidebarTab('${tab}')"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }
            
            // Update principles if on principles tab
            if (tab === 'principles') {
                updatePrinciplesList();
                showRandomTip();
            }
        }
        
        function updatePrinciplesList() {
            try {
                const list = document.getElementById('principles-list');
                if (!list) return;
                
                const mode = document.querySelector('.mode-btn.active')?.classList.contains('grinde') ? 'grinde' : 'buzan';
                
                if (mode === 'grinde') {
                    list.innerHTML = `
                        <div style="font-size: 14px; line-height: 1.6;">
                            <div style="margin-bottom: 10px;">‚úÖ <strong>G</strong> - ${t('principles.g')}</div>
                            <div style="margin-bottom: 10px;">‚úÖ <strong>R</strong> - ${t('principles.r')}</div>
                            <div style="margin-bottom: 10px;">‚úÖ <strong>I</strong> - ${t('principles.i')}</div>
                            <div style="margin-bottom: 10px;">‚úÖ <strong>N</strong> - ${t('principles.n')}</div>
                            <div style="margin-bottom: 10px;">‚úÖ <strong>D</strong> - ${t('principles.d')}</div>
                            <div style="margin-bottom: 10px;">‚úÖ <strong>E</strong> - ${t('principles.e')}</div>
                        </div>
                    `;
                } else {
                    list.innerHTML = `
                        <div style="font-size: 14px; line-height: 1.6;">
                            <div style="margin-bottom: 10px;">üåü ${t('buzan.radiant')}</div>
                            <div style="margin-bottom: 10px;">üåü ${t('buzan.keyword')}</div>
                            <div style="margin-bottom: 10px;">üåü ${t('buzan.colors')}</div>
                            <div style="margin-bottom: 10px;">üåü ${t('buzan.images')}</div>
                            <div style="margin-bottom: 10px;">üåü ${t('buzan.curves')}</div>
                            <div style="margin-bottom: 10px;">üåü ${t('buzan.hierarchy')}</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error updating principles list:', error);
            }
        }
        
        function showRandomTip() {
            try {
                const tipsElement = document.getElementById('tips-random');
                if (!tipsElement) return;
                
                const tips = [
                    t('tip.doubleclick'),
                    t('tip.shift'),
                    t('tip.wheel'),
                    t('tip.delete'),
                    t('tip.save'),
                    t('tip.curves'),
                    t('tip.words'),
                    t('tip.colors')
                ];
                
                const randomTip = tips[Math.floor(Math.random() * tips.length)];
                tipsElement.textContent = randomTip;
            } catch (error) {
                console.error('Error showing random tip:', error);
            }
        }
        
        // Templates
        async function loadTemplate(templateId) {
            try {
                const response = await fetchApi(`/api/template/${templateId}`);
                const result = await response.json();
                
                if (result.success) {
                    const data = result.data;
                    
                    // Create new map from template
                    currentMap = {
                        id: null,
                        title: data.title,
                        mode: data.mode,
                        nodes: [],
                        connections: []
                    };
                    
                    // Add nodes
                    const nodeMap = {};
                    data.nodes.forEach(n => {
                        const node = new Node(n.x, n.y, n.text, n.type);
                        node.id = n.id;
                        node.color = n.color;
                        node.size = n.size;
                        nodeMap[n.id] = node;
                        currentMap.nodes.push(node);
                    });
                    
                    // Add connections
                    data.connections.forEach(c => {
                        const conn = new Connection(nodeMap[c.source], nodeMap[c.target], c.type);
                        currentMap.connections.push(conn);
                    });
                    
                    setMode(currentMap.mode);
                    showToast(t('toast.loaded'), 'success');
                }
            } catch (error) {
                showToast(t('toast.error'), 'error');
            }
        }
        
        // History
        function saveHistory() {
            // Remove future history if we're not at the end
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            // Save current state
            history.push(JSON.stringify({
                nodes: currentMap.nodes.map(n => ({
                    id: n.id,
                    x: n.x,
                    y: n.y,
                    text: n.text,
                    type: n.type,
                    size: n.size,
                    color: n.color
                })),
                connections: currentMap.connections.map(c => ({
                    sourceId: c.source.id,
                    targetId: c.target.id,
                    type: c.type,
                    color: c.color
                }))
            }));
            
            historyIndex++;
            
            // Limit history size
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }
        
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreFromHistory();
            }
        }
        
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreFromHistory();
            }
        }
        
        function restoreFromHistory() {
            const state = JSON.parse(history[historyIndex]);
            
            // Restore nodes
            const nodeMap = {};
            currentMap.nodes = state.nodes.map(n => {
                const node = new Node(n.x, n.y, n.text, n.type);
                node.id = n.id;
                node.size = n.size;
                node.color = n.color;
                nodeMap[n.id] = node;
                return node;
            });
            
            // Restore connections
            currentMap.connections = state.connections.map(c => {
                const conn = new Connection(nodeMap[c.sourceId], nodeMap[c.targetId], c.type);
                conn.color = c.color;
                return conn;
            });
        }
        
        // AutoSave Toggle Functions
        function toggleAutoSave() {
            const toggle = document.getElementById('autosaveToggle');
            autoSaveEnabled = toggle.checked;
            
            // Save preference to localStorage
            localStorage.setItem('autosave.enabled', autoSaveEnabled);
            
            if (autoSaveEnabled) {
                startAutoSave();
                console.log('AutoSave enabled');
            } else {
                stopAutoSave();
                console.log('AutoSave disabled');
            }
        }
        
        function startAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            
            if (autoSaveEnabled) {
                autoSaveTimer = setInterval(async () => {
                    if (currentMap.id) {
                        console.log('AutoSave: Saving map...');
                        await saveCurrentMap();
                    }
                }, autoSaveFrequency * 1000);
            }
        }
        
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }
        
        async function loadAutoSaveSettings() {
            try {
                // Try to load default settings from server
                const response = await fetchApi('/api/settings');
                if (response.ok) {
                    const settings = await response.json();
                    if (settings.autosave) {
                        autoSaveEnabled = settings.autosave.default;
                        autoSaveFrequency = settings.autosave.frequency_seconds || 60;
                    }
                }
            } catch (error) {
                console.log('Could not load server settings, using defaults');
            }
            
            // Load user preferences from localStorage (overrides server defaults)
            const savedEnabled = localStorage.getItem('autosave.enabled');
            const savedFrequency = localStorage.getItem('autosave.frequency_seconds');
            
            if (savedEnabled !== null) {
                autoSaveEnabled = savedEnabled === 'true';
            }
            
            if (savedFrequency) {
                autoSaveFrequency = parseInt(savedFrequency);
            }
            
            // Update UI
            document.getElementById('autosaveToggle').checked = autoSaveEnabled;
            
            if (autoSaveEnabled) {
                startAutoSave();
            }
        }
        
        async function saveCurrentMap() {
            if (!currentMap.id) return;
            
            try {
                const response = await fetchApi('/api/autosave', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: currentMap.id,
                        title: currentMap.title,
                        mode: currentMap.mode,
                        nodes: currentMap.nodes.map(n => ({
                            id: n.id,
                            x: n.x,
                            y: n.y,
                            text: n.text,
                            type: n.type,
                            size: n.size,
                            color: n.color,
                            textColor: n.textColor,
                            shape: n.shape,
                            shapeWidth: n.shapeWidth,
                            shapeHeight: n.shapeHeight
                        })),
                        connections: currentMap.connections.map(c => ({
                            source: { id: c.source.id },
                            target: { id: c.target.id },
                            text: c.text,
                            type: c.type,
                            color: c.color
                        })),
                        stylo_drawings: currentMap.stylo_drawings || []
                    })
                });
                
                if (response.ok) {
                    console.log('AutoSave: Map saved successfully');
                } else {
                    console.error('AutoSave: Failed to save map');
                }
            } catch (error) {
                console.error('AutoSave: Error saving map:', error);
            }
        }
        
        // Autosave
        function autosave() {
            clearTimeout(autosaveTimer);
            autosaveTimer = setTimeout(async () => {
                try {
                    await fetchApi('/api/autosave', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: currentMap.id || 'temp',
                            title: currentMap.title || 'Untitled Map',
                            mode: currentMap.mode || 'grinde',
                            nodes: currentMap.nodes.map(n => ({
                                id: n.id,
                                x: n.x,
                                y: n.y,
                                text: n.text,
                                type: n.type,
                                size: n.size,
                                color: n.color,
                                shape: n.shape
                            })),
                            connections: currentMap.connections.map(c => ({
                                source: c.source.id,
                                target: c.target.id,
                                type: c.type,
                                color: c.color,
                                text: c.text || ''
                            })),
                            stylo_drawings: currentMap.stylo_drawings || [],
                            modified: new Date().toISOString(),
                            created: currentMap.created || new Date().toISOString(),
                            metadata: {
                                language: currentLanguage
                            }
                        })
                    });
                } catch (error) {
                    console.error('Autosave failed');
                }
            }, 2000);
        }
        
        // UI Helpers
        function showGuide() {
            document.getElementById('guideModal').classList.add('active');
        }
        
        function showGuideModal() {
            showGuide();
        }
        
        function showTemplatesModal() {
            // For now, show the same guide modal - can be enhanced later
            showGuide();
        }
        
        function showShortcutsModal() {
            // For now, show the same guide modal - can be enhanced later  
            showGuide();
        }
        
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.remove('active');
            modal.style.display = 'none';
        }
        
        function toggleFabMenu() {
            console.log('toggleFabMenu called');
            const fabMenu = document.getElementById('fabMenu');
            console.log('fabMenu element:', fabMenu);
            if (fabMenu) {
                fabMenu.classList.toggle('active');
                console.log('fabMenu classes:', fabMenu.classList.toString());
            }
        }
        
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Stylo drawings utility functions
        function findDrawingAtPoint(x, y) {
            if (!currentMap.stylo_drawings) return null;
            
            const tolerance = 10; // Tolerance in pixels for clicking on a line
            
            for (let drawing of currentMap.stylo_drawings) {
                if (drawing.type === 'straight_line') {
                    // Calculate distance from point to line
                    const distance = distancePointToLine(x, y, drawing.x1, drawing.y1, drawing.x2, drawing.y2);
                    if (distance <= tolerance + drawing.size / 2) {
                        return drawing;
                    }
                }
            }
            return null;
        }
        
        function distancePointToLine(px, py, x1, y1, x2, y2) {
            // Calculate the distance from point (px, py) to line segment (x1,y1)-(x2,y2)
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) {
                // Line segment is a point
                return Math.sqrt(A * A + B * B);
            }
            
            let param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Utility function to check if a line intersects with a rectangle
        function lineIntersectsRect(x1, y1, x2, y2, rectMinX, rectMinY, rectMaxX, rectMaxY) {
            // Check if either endpoint is inside the rectangle
            if ((x1 >= rectMinX && x1 <= rectMaxX && y1 >= rectMinY && y1 <= rectMaxY) ||
                (x2 >= rectMinX && x2 <= rectMaxX && y2 >= rectMinY && y2 <= rectMaxY)) {
                return true;
            }
            
            // Check if line crosses any edge of the rectangle
            return (
                lineIntersectsLine(x1, y1, x2, y2, rectMinX, rectMinY, rectMaxX, rectMinY) || // top
                lineIntersectsLine(x1, y1, x2, y2, rectMaxX, rectMinY, rectMaxX, rectMaxY) || // right
                lineIntersectsLine(x1, y1, x2, y2, rectMaxX, rectMaxY, rectMinX, rectMaxY) || // bottom
                lineIntersectsLine(x1, y1, x2, y2, rectMinX, rectMaxY, rectMinX, rectMinY)    // left
            );
        }
        
        // Helper function to check if two lines intersect
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (denominator === 0) return false; // parallel lines
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;
            
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

        function removeDrawing(drawingId) {
            if (!currentMap.stylo_drawings) return;
            
            const index = currentMap.stylo_drawings.findIndex(d => d.id === drawingId);
            if (index !== -1) {
                // Ask for confirmation before deleting
                if (confirm('√ätes-vous s√ªr de vouloir supprimer ce dessin ?')) {
                    currentMap.stylo_drawings.splice(index, 1);
                    
                    // Show success message
                    showToast('Supprim√©', 'success');
                    
                    // Update display and save
                    render();
                    saveHistory();
                    autosave();
                    
                    console.log('Drawing removed:', drawingId);
                }
            }
        }
        
        function updateStats() {
            document.getElementById('nodeCount').textContent = currentMap.nodes.length;
            document.getElementById('connectionCount').textContent = currentMap.connections.length;
        }
        
        // Menu dropdown functionality
        function initMenus() {
            const menuItems = document.querySelectorAll('.menu-item');
            
            menuItems.forEach(item => {
                const button = item.querySelector('.menu-button');
                const dropdown = item.querySelector('.menu-dropdown');
                
                // Handle clicks on mobile
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Close other dropdowns first
                    menuItems.forEach(otherItem => {
                        if (otherItem !== item) {
                            otherItem.querySelector('.menu-dropdown').style.display = 'none';
                        }
                    });
                    
                    // Toggle current dropdown
                    const isOpen = dropdown.style.display === 'block';
                    dropdown.style.display = isOpen ? 'none' : 'block';
                });
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', () => {
                menuItems.forEach(item => {
                    item.querySelector('.menu-dropdown').style.display = 'none';
                });
            });
            
            // Close modals when clicking outside
            window.addEventListener('click', (event) => {
                const loadMapModal = document.getElementById('loadMapModal');
                const guideModal = document.getElementById('guideModal');
                
                if (event.target === loadMapModal) {
                    closeModal('loadMapModal');
                }
                if (event.target === guideModal) {
                    closeModal('guideModal');
                }
            });
        }
        
        // Tools Container Dynamic CSS and Functionality
        function initToolsContainer() {
            const style = document.createElement('style');
            style.textContent = `
                .tool-group.tools-group {
                    background: #ffffff;
                    border: 2px solid #e5e7eb;
                    border-radius: 12px;
                    padding: 12px;
                    margin-right: 15px;
                    margin-left: 50px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    min-width: 200px;
                }
                
                .tool-group.tools-group .tool-group-label {
                    color: #374151;
                    font-weight: 600;
                    font-size: 11px;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    margin-bottom: 8px;
                    display: block;
                    text-align: center;
                }
                
                .tool-group.tools-group .tool-btn {
                    background: #2d3748;
                    border: 1px solid #4a5568;
                    color: #e2e8f0;
                    width: 36px;
                    height: 36px;
                    border-radius: 6px;
                    margin: 2px;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    font-size: 14px;
                }
                
                .tool-group.tools-group .tool-btn:hover {
                    background: #4a5568;
                    border-color: #718096;
                    transform: translateY(-1px);
                }
                
                .tool-group.tools-group .tool-btn.active {
                    background: #3182ce;
                    border-color: #2b77cb;
                    color: white;
                    box-shadow: 0 0 0 2px rgba(49, 130, 206, 0.3);
                }
                
                .tool-row {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    margin-top: 8px;
                    padding-top: 8px;
                    border-top: 1px solid #4a5568;
                }
                
                .size-chooser {
                    display: none; /* Hidden by default */
                    gap: 4px;
                    justify-content: center;
                    align-items: center;
                    flex-wrap: wrap;
                }
                
                .size-chooser.pen-active {
                    display: flex; /* Show only when pen tool is active */
                }
                
                .size-btn {
                    background: #2d3748;
                    border: 1px solid #4a5568;
                    color: #e2e8f0;
                    width: 28px;
                    height: 28px;
                    border-radius: 4px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s ease;
                    font-size: 8px;
                    margin: 1px;
                }
                
                .size-btn[data-size="1"] { font-size: 6px; }
                .size-btn[data-size="2"] { font-size: 8px; }
                .size-btn[data-size="4"] { font-size: 10px; }
                .size-btn[data-size="8"] { font-size: 12px; }
                .size-btn[data-size="12"] { font-size: 14px; }
                .size-btn[data-size="20"] { font-size: 16px; }
                
                .size-btn:hover {
                    background: #4a5568;
                    border-color: #718096;
                }
                
                .size-btn.active {
                    background: #3182ce;
                    border-color: #2b77cb;
                    color: white;
                }
                
                .color-chooser {
                    display: none; /* Hidden by default */
                    gap: 4px;
                    justify-content: center;
                    align-items: center;
                    flex-wrap: wrap;
                }
                
                .color-chooser.pen-active {
                    display: flex; /* Show only when pen tool is active */
                }
                
                .color-btn {
                    width: 24px;
                    height: 24px;
                    border: 2px solid #4a5568;
                    border-radius: 4px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    margin: 1px;
                }
                
                .color-btn:hover {
                    transform: scale(1.1);
                    border-color: #718096;
                }
                
                .color-btn.active {
                    border-color: #ffffff;
                    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
                }
            `;
            document.head.appendChild(style);
            
            // Initialize tool functionality
            let currentTool = 'lasso';
            let currentSize = 4;
            let currentColor = '#1e90ff';
            
            // Tool button functionality
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    const tool = this.id.replace('Tool', '');
                    setTool(tool);
                });
            });
            
            // Size chooser functionality
            document.querySelectorAll('.size-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentSize = parseInt(this.dataset.size);
                    selectedPenSize = parseInt(this.dataset.size); // Update pen size
                });
            });
            
            // Color chooser functionality
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentColor = this.dataset.color;
                    selectedPenColor = this.dataset.color; // Update pen color
                });
            });
            
            // Set default active states
            document.querySelector('#lassoTool').classList.add('active');
            document.querySelector('[data-size="4"]').classList.add('active');
            document.querySelector('[data-color="#1e90ff"]').classList.add('active');
        }
        
        // Tool functions  
        function setToolFromContainer(tool) {
            // Update the main setTool function
            setTool(tool);
            
            // Show/hide pen controls based on selected tool
            const sizeChooser = document.getElementById('sizeChooser');
            const colorChooser = document.getElementById('colorChooser');
            
            if (tool === 'pen') {
                sizeChooser.classList.add('pen-active');
                colorChooser.classList.add('pen-active');
            } else {
                sizeChooser.classList.remove('pen-active');
                colorChooser.classList.remove('pen-active');
            }
            
            console.log(`Outil s√©lectionn√©: ${tool}`);
        }
        
        // Initialize on load
        window.addEventListener('load', function() {
            init();
            initToolsContainer();
        });
    </script>
</body>
</html>